<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>cevast.certdb API documentation</title>
<meta name="description" content="CertDB is a database managing X.509 certificates." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cevast.certdb</code></h1>
</header>
<section id="section-intro">
<p>CertDB is a database managing X.509 certificates.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;CertDB is a database managing X.509 certificates.&#34;&#34;&#34;

__all__ = (
    &#39;CertDB&#39;,
    &#39;CertDBReadOnly&#39;,
    &#39;CertFileDB&#39;,
    &#39;CertFileDBReadOnly&#39;,
    &#39;CertNotAvailableError&#39;,
    &#39;CertInvalidError&#39;,
    &#39;CompositeCertDB&#39;,
    &#39;CompositeCertDBReadOnly&#39;,
)
__version__ = &#39;0.1&#39;
__author__ = &#39;Radim Podola&#39;

from .cert_db import CertNotAvailableError, CertInvalidError, CertDB, CertDBReadOnly
from .cert_file_db import CertFileDBReadOnly, CertFileDB
from .composite_cert_db import CompositeCertDB, CompositeCertDBReadOnly</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="cevast.certdb.cert_db" href="cert_db.html">cevast.certdb.cert_db</a></code></dt>
<dd>
<div class="desc"><p>This module provides interface of CertDB class …</p></div>
</dd>
<dt><code class="name"><a title="cevast.certdb.cert_file_db" href="cert_file_db.html">cevast.certdb.cert_file_db</a></code></dt>
<dd>
<div class="desc"><p>This module contains implementation of CertFileDB …</p></div>
</dd>
<dt><code class="name"><a title="cevast.certdb.cli" href="cli.html">cevast.certdb.cli</a></code></dt>
<dd>
<div class="desc"><p>Group of CLI commands used for CertDB management and access …</p></div>
</dd>
<dt><code class="name"><a title="cevast.certdb.composite_cert_db" href="composite_cert_db.html">cevast.certdb.composite_cert_db</a></code></dt>
<dd>
<div class="desc"><p>This module contains implementation of CompositeCertDB …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cevast.certdb.CertDB"><code class="flex name class">
<span>class <span class="ident">CertDB</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract class representing CertDB interface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CertDB(CertDBReadOnly):
    &#34;&#34;&#34;Abstract class representing CertDB interface.&#34;&#34;&#34;

    @abstractmethod
    def insert(self, cert_id: str, cert: str) -&gt; None:
        &#34;&#34;&#34;
        Insert the certificate to the database under `cert_id` identifier.

        Inserted certificate is not persisted immediatelly but
        remains in current open transaction untill commit or rollback.
        A expected format of certificate is PEM.
        &#34;&#34;&#34;

    @abstractmethod
    def delete(self, cert_id: str) -&gt; None:
        &#34;&#34;&#34;
        Delete the certificate from the database.

        Persisted certificate is not immediatelly deleted but
        remains untill commit or rollback. Certificate inserted
        in the current transaction is deleted immediatelly.
        &#34;&#34;&#34;

    @abstractmethod
    def rollback(self) -&gt; None:
        &#34;&#34;&#34;
        Revert the changes made by the current transaction.

        All inserted certificates waiting to persist are removed.
        All deleted certificates in the current transaction stay untouched.
        &#34;&#34;&#34;

    @abstractmethod
    def commit(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;
        Apply the changes made by the current transaction.

        All inserted certificates waiting to persist are persisted.
        All deleted certificates in the current transaction are permanently removed.
        Return tuple of numbers (number of inserted; number of deleted)
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cevast.certdb.cert_db.CertDBReadOnly" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly">CertDBReadOnly</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="cevast.certdb.cert_file_db.CertFileDB" href="cert_file_db.html#cevast.certdb.cert_file_db.CertFileDB">CertFileDB</a></li>
<li><a title="cevast.certdb.composite_cert_db.CompositeCertDB" href="composite_cert_db.html#cevast.certdb.composite_cert_db.CompositeCertDB">CompositeCertDB</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cevast.certdb.CertDB.commit"><code class="name flex">
<span>def <span class="ident">commit</span></span>(<span>self) -> Tuple[int, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the changes made by the current transaction.</p>
<p>All inserted certificates waiting to persist are persisted.
All deleted certificates in the current transaction are permanently removed.
Return tuple of numbers (number of inserted; number of deleted)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def commit(self) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;
    Apply the changes made by the current transaction.

    All inserted certificates waiting to persist are persisted.
    All deleted certificates in the current transaction are permanently removed.
    Return tuple of numbers (number of inserted; number of deleted)
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="cevast.certdb.CertDB.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, cert_id: str) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the certificate from the database.</p>
<p>Persisted certificate is not immediatelly deleted but
remains untill commit or rollback. Certificate inserted
in the current transaction is deleted immediatelly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def delete(self, cert_id: str) -&gt; None:
    &#34;&#34;&#34;
    Delete the certificate from the database.

    Persisted certificate is not immediatelly deleted but
    remains untill commit or rollback. Certificate inserted
    in the current transaction is deleted immediatelly.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="cevast.certdb.CertDB.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, cert_id: str, cert: str) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Insert the certificate to the database under <code>cert_id</code> identifier.</p>
<p>Inserted certificate is not persisted immediatelly but
remains in current open transaction untill commit or rollback.
A expected format of certificate is PEM.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def insert(self, cert_id: str, cert: str) -&gt; None:
    &#34;&#34;&#34;
    Insert the certificate to the database under `cert_id` identifier.

    Inserted certificate is not persisted immediatelly but
    remains in current open transaction untill commit or rollback.
    A expected format of certificate is PEM.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="cevast.certdb.CertDB.rollback"><code class="name flex">
<span>def <span class="ident">rollback</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Revert the changes made by the current transaction.</p>
<p>All inserted certificates waiting to persist are removed.
All deleted certificates in the current transaction stay untouched.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def rollback(self) -&gt; None:
    &#34;&#34;&#34;
    Revert the changes made by the current transaction.

    All inserted certificates waiting to persist are removed.
    All deleted certificates in the current transaction stay untouched.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="cevast.certdb.cert_db.CertDBReadOnly" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly">CertDBReadOnly</a></b></code>:
<ul class="hlist">
<li><code><a title="cevast.certdb.cert_db.CertDBReadOnly.exists" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.exists">exists</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDBReadOnly.exists_all" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.exists_all">exists_all</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDBReadOnly.export" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.export">export</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDBReadOnly.get" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.get">get</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="cevast.certdb.CertDBReadOnly"><code class="flex name class">
<span>class <span class="ident">CertDBReadOnly</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract class representing read-only CertDB interface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CertDBReadOnly(ABC):
    &#34;&#34;&#34;Abstract class representing read-only CertDB interface.&#34;&#34;&#34;

    @abstractmethod
    def get(self, cert_id: str) -&gt; str:
        &#34;&#34;&#34;
        Retrieve a certificate from the database.

        `cert_id` is the certificate identifier.
        Certificate is returned in a PEM format.
        Raise CertNotAvailableError if the certificate is not found.
        &#34;&#34;&#34;

    @abstractmethod
    def export(self, cert_id: str, target_dir: str, copy_if_exists: bool = True) -&gt; str:
        &#34;&#34;&#34;
        Export a certificate from the database and saves it as a PEM file.

        `cert_id` is the certificate identifier,
        `target_dir` is the target directory.
        If `copy_if_exists` is false and file already exists (e.g. temporary in open transaction),
        the file is not copied to the target directory, instead the existing file path is returned.

        Full path of the certificate file is returned.
        Raise CertNotAvailableError if the certificate is not found.
        &#34;&#34;&#34;

    @abstractmethod
    def exists(self, cert_id: str) -&gt; bool:
        &#34;&#34;&#34;
        Test whether a certificate exists in the database.

        `cert_id` is the certificate cert_identifier.
        &#34;&#34;&#34;

    @abstractmethod
    def exists_all(self, cert_ids: list) -&gt; bool:
        &#34;&#34;&#34;
        Test that all certificates exist in the database.

        `cert_ids` is a list of certificate identifiers.
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="cevast.certdb.cert_db.CertDB" href="cert_db.html#cevast.certdb.cert_db.CertDB">CertDB</a></li>
<li><a title="cevast.certdb.cert_file_db.CertFileDBReadOnly" href="cert_file_db.html#cevast.certdb.cert_file_db.CertFileDBReadOnly">CertFileDBReadOnly</a></li>
<li><a title="cevast.certdb.composite_cert_db.CompositeCertDBReadOnly" href="composite_cert_db.html#cevast.certdb.composite_cert_db.CompositeCertDBReadOnly">CompositeCertDBReadOnly</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cevast.certdb.CertDBReadOnly.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>self, cert_id: str) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Test whether a certificate exists in the database.</p>
<p><code>cert_id</code> is the certificate cert_identifier.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def exists(self, cert_id: str) -&gt; bool:
    &#34;&#34;&#34;
    Test whether a certificate exists in the database.

    `cert_id` is the certificate cert_identifier.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="cevast.certdb.CertDBReadOnly.exists_all"><code class="name flex">
<span>def <span class="ident">exists_all</span></span>(<span>self, cert_ids: list) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Test that all certificates exist in the database.</p>
<p><code>cert_ids</code> is a list of certificate identifiers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def exists_all(self, cert_ids: list) -&gt; bool:
    &#34;&#34;&#34;
    Test that all certificates exist in the database.

    `cert_ids` is a list of certificate identifiers.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="cevast.certdb.CertDBReadOnly.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, cert_id: str, target_dir: str, copy_if_exists: bool = True) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Export a certificate from the database and saves it as a PEM file.</p>
<p><code>cert_id</code> is the certificate identifier,
<code>target_dir</code> is the target directory.
If <code>copy_if_exists</code> is false and file already exists (e.g. temporary in open transaction),
the file is not copied to the target directory, instead the existing file path is returned.</p>
<p>Full path of the certificate file is returned.
Raise CertNotAvailableError if the certificate is not found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def export(self, cert_id: str, target_dir: str, copy_if_exists: bool = True) -&gt; str:
    &#34;&#34;&#34;
    Export a certificate from the database and saves it as a PEM file.

    `cert_id` is the certificate identifier,
    `target_dir` is the target directory.
    If `copy_if_exists` is false and file already exists (e.g. temporary in open transaction),
    the file is not copied to the target directory, instead the existing file path is returned.

    Full path of the certificate file is returned.
    Raise CertNotAvailableError if the certificate is not found.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="cevast.certdb.CertDBReadOnly.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, cert_id: str) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a certificate from the database.</p>
<p><code>cert_id</code> is the certificate identifier.
Certificate is returned in a PEM format.
Raise CertNotAvailableError if the certificate is not found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def get(self, cert_id: str) -&gt; str:
    &#34;&#34;&#34;
    Retrieve a certificate from the database.

    `cert_id` is the certificate identifier.
    Certificate is returned in a PEM format.
    Raise CertNotAvailableError if the certificate is not found.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cevast.certdb.CertFileDB"><code class="flex name class">
<span>class <span class="ident">CertFileDB</span></span>
<span>(</span><span>storage: str, cpu_cores: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>CertDB interface implementation which uses files
and a file system properties as a storage mechanism.</p>
<p><code>storage</code> is path to the database storage.
<code>cpu_cores</code> is max number of CPU cores that might be used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CertFileDB(CertDB, CertFileDBReadOnly):
    &#34;&#34;&#34;
    CertDB interface implementation which uses files
    and a file system properties as a storage mechanism.

    `storage` is path to the database storage.
    `cpu_cores` is max number of CPU cores that might be used.
    &#34;&#34;&#34;

    def __init__(self, storage: str, cpu_cores: int = 1):
        CertFileDBReadOnly.__init__(self, storage)
        # Dict containing all inserted certificates grouped in blocks that will be persisted with commit
        self._to_insert: dict = {}
        # Dict containing all deleted certificates grouped in blocks that will be deleted with commit
        self._to_delete: dict = {}
        # Max number of CPU cores that can be used (-1 is max limit by hardware)
        self.__cpu_cores = int(cpu_cores)
        log.info(&#39;Will use %d CPUs&#39;, self.__cpu_cores)

    def get(self, cert_id: str) -&gt; str:
        # Check if certificate exists as a file (transaction still open)
        if self._is_in_transaction(cert_id, self._to_insert):
            cert_file = self._get_block_path(cert_id) + cert_id
            with open(cert_file, &#39;r&#39;) as source:
                log.debug(&#39;&lt;%s&gt; found in open transaction&#39;, cert_file)
                return source.read()
        # Check if certificate is scheduled for delete
        if self._is_in_transaction(cert_id, self._to_delete):
            log.info(&#39;&lt;%s&gt; was deleted in current transaction&#39;, cert_id)
            raise CertNotAvailableError(cert_id)
        # Check if certificate exists persisted
        return CertFileDBReadOnly.get(self, cert_id)

    def export(self, cert_id: str, target_dir: str, copy_if_exists: bool = True) -&gt; str:
        # Check if certificate exists as a file (transaction still open)
        if self._is_in_transaction(cert_id, self._to_insert):
            cert_src_file = self._get_block_path(cert_id) + cert_id
            log.debug(&#39;&lt;%s&gt; found in open transaction&#39;, cert_src_file)
            if not copy_if_exists:
                return cert_src_file
            # Copy file to the target directory
            cert_trg_file = os.path.join(target_dir, make_PEM_filename(cert_id))
            shutil.copyfile(cert_src_file, cert_trg_file)
            return cert_trg_file
        # Check if certificate is scheduled for delete
        if self._is_in_transaction(cert_id, self._to_delete):
            log.info(&#39;&lt;%s&gt; was deleted in current transaction&#39;, cert_id)
            raise CertNotAvailableError(cert_id)
        # Check if certificate exists persisted
        return CertFileDBReadOnly.export(self, cert_id, target_dir, copy_if_exists)

    def exists(self, cert_id: str) -&gt; bool:
        # Check the open transaction first
        if self._is_in_transaction(cert_id, self._to_insert):
            log.debug(&#39;&lt;%s&gt; exists in open transaction&#39;, cert_id)
            return True
        # Check if certificate is scheduled for delete
        if self._is_in_transaction(cert_id, self._to_delete):
            log.info(&#39;&lt;%s&gt; was deleted in current transaction&#39;, cert_id)
            return False
        # Check if certificate exists persisted
        return CertFileDBReadOnly.exists(self, cert_id)

    def insert(self, cert_id: str, cert: str) -&gt; None:
        if not cert_id or not cert:
            raise CertInvalidError(&#39;cert_id &lt;{}&gt; or cert &lt;{}&gt; invalid&#39;.format(cert_id, cert))
        # Save certificate to temporary file
        block = self._get_block_path(cert_id)
        cert_file = block + cert_id
        if os.path.exists(cert_file):
            log.info(&#39;Certificate %s already exists&#39;, cert_file)
        else:
            try:
                with open(cert_file, &#39;w&#39;) as w_file:
                    w_file.write(cert)
            except FileNotFoundError:
                os.makedirs(block, exist_ok=True)
                with open(cert_file, &#39;w&#39;) as w_file:
                    w_file.write(cert)
        # Add certificate to transaction for insert upon commit
        self._add_to_transaction(cert_id, self._to_insert)
        log.debug(&#39;Certificate %s inserted to block %s&#39;, cert_id, block)

    def delete(self, cert_id: str) -&gt; None:
        if not cert_id:
            raise CertInvalidError(&#39;cert_id &lt;{}&gt; invalid&#39;.format(cert_id))

        if self._is_in_transaction(cert_id, self._to_insert):
            # Immediatelly delete certificate in open transaction if exists
            cert_file = self._get_block_path(cert_id) + cert_id
            self._remove_from_transaction(cert_id, self._to_insert)
            os.remove(cert_file)
            log.debug(&#39;Certificate %s deleted from open transaction&#39;, cert_id)
        else:
            # Add certificate to transaction for delete upon commit
            self._add_to_transaction(cert_id, self._to_delete)
            log.debug(&#39;Certificate %s will be deleted upon commit&#39;, cert_id)

        # Delete certificates from cache
        self._cache.discard(cert_id)

    def rollback(self) -&gt; None:
        log.info(&#39;Rollback started&#39;)
        # Remove uncommitted certificates
        for block, certs in self._to_insert.items():
            block_path = self._get_block_path(block)
            for cert_id in certs:
                os.remove(block_path + cert_id)
        self._to_insert.clear()
        self._to_delete.clear()
        # Clean up empty folders
        remove_empty_folders(self.storage)
        log.info(&#39;Rollback finished&#39;)

    def commit(self) -&gt; Tuple[int, int]:
        log.info(&#39;Commit started&#39;)
        cnt_deleted = 0
        cnt_inserted = 0

        if self.__cpu_cores != 1:
            cnt_inserted, cnt_deleted = self.__commit_async()
        else:
            # Handle delete first because sequence matter
            for block, certs in self._to_delete.items():
                cnt_deleted += CertFileDB.delete_certs(self._get_block_archive(block), certs)
            # Now handle insert
            for block, certs in self._to_insert.items():
                cnt_inserted += CertFileDB.persist_certs(self._get_block_path(block), self._get_block_archive(block), certs)

        self._to_delete.clear()
        self._to_insert.clear()
        log.info(&#39;Deleted %d certificates&#39;, cnt_deleted)
        log.info(&#39;Inserted %d certificates&#39;, cnt_inserted)
        # Clean up empty folders
        remove_empty_folders(self.storage)  # TODO seems not working properly in benchmark
        # Write commit info
        if self._params[&#39;maintain_info&#39;]:
            self.__write_commit_info(cnt_inserted, cnt_deleted)
        log.info(&#39;Commit finished&#39;)
        return cnt_inserted, cnt_deleted

    def __commit_async(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;
        Function acomplishing the same as commit() but with use of multiprocessing.Pool
        of asynchronous workers to persist/delete multiple certificate blocks in parallel.
        &#34;&#34;&#34;
        cnt_deleted = 0
        cnt_inserted = 0
        cpus = self.__cpu_cores if self.__cpu_cores &gt; 0 else None

        pool = mp.Pool(cpus)
        # Handle delete first because sequence matter
        results = []
        for block, certs in self._to_delete.items():
            results.append(pool.apply_async(CertFileDB.delete_certs, args=(self._get_block_archive(block), certs)))
        cnt_deleted = sum([result.get() for result in results])
        # Now handle insert
        results = []
        for block, certs in self._to_insert.items():
            results.append(
                pool.apply_async(
                    CertFileDB.persist_certs, args=(self._get_block_path(block), self._get_block_archive(block), certs)
                )
            )
        cnt_inserted = sum([result.get() for result in results])
        pool.close()
        pool.join()

        return cnt_inserted, cnt_deleted

    # static so I can use it in async pool or find a way hot to use private
    @staticmethod
    def delete_certs(block_archive: str, certs: set) -&gt; int:
        &#34;&#34;&#34;Delete persisted certificates from block archive&#34;&#34;&#34;
        cnt_deleted = 0
        if certs and os.path.exists(block_archive):
            deleted_all = True
            new_block_archive = block_archive + &#39;_new&#39;
            with ZipFile(block_archive, &#39;r&#39;, ZIP_STORED) as zin,\
                 ZipFile(new_block_archive, &#39;w&#39;, ZIP_STORED) as zout:
                for name in zin.namelist():
                    if os.path.splitext(name)[0] not in certs:
                        zout.writestr(name, zin.read(name))
                        deleted_all = False
                    else:
                        cnt_deleted += 1
            # Remove the original zipfile and replace it with new one
            os.remove(block_archive)
            if deleted_all:
                # Delete the empty zipfile
                os.remove(new_block_archive)
            else:
                os.rename(new_block_archive, block_archive)

        log.debug(&#39;Deleted %d certificates from block %s&#39;, cnt_deleted, block_archive)
        return cnt_deleted

    # static so I can use it in async pool
    @staticmethod
    def persist_certs(block_path: str, block_archive: str, certs: set) -&gt; int:
        &#34;&#34;&#34;Persist certificates to block archive&#34;&#34;&#34;
        if not certs:
            log.debug(&#39;Nothing to insert from block %s&#39;, block_path)
            return 0
        cnt_inserted = 0
        if os.path.exists(block_archive):
            append = True
            log.debug(&#39;Appending to archive: %s&#39;, block_archive)
        else:
            append = False
            log.debug(&#39;Creating archive: %s&#39;, block_archive)

        # TODO compare performance for higher compresslevel
        with ZipFile(block_archive, &#34;a&#34; if append else &#34;w&#34;, ZIP_STORED) as zout:
            if append:
                persisted_certs = zout.namelist()

            for cert in certs:
                cert_file = block_path + cert
                if append and cert in persisted_certs:
                    pass  # do not insert duplicates
                else:
                    zout.write(cert_file, cert)
                    cnt_inserted += 1
                os.remove(cert_file)

        log.debug(&#39;Persisted %d certificates from block %s&#39;, cnt_inserted, block_path)
        return cnt_inserted

    def _is_in_transaction(self, cert_id: str, trans_dict: dict) -&gt; bool:
        return cert_id in trans_dict.get(self._get_block_id(cert_id), {})

    def _add_to_transaction(self, cert_id: str, trans_dict: dict) -&gt; None:
        block_id = self._get_block_id(cert_id)
        try:
            trans_dict[block_id].add(cert_id)
        except KeyError:
            trans_dict[block_id] = set()
            trans_dict[block_id].add(cert_id)

    def _remove_from_transaction(self, cert_id: str, trans_dict: dict) -&gt; None:
        block_id = self._get_block_id(cert_id)
        try:
            trans_dict[block_id].discard(cert_id)
            if not trans_dict[block_id]:
                del trans_dict[block_id]
        except KeyError:
            pass

    def __write_commit_info(self, inserted: int, deleted: int) -&gt; None:
        meta_path = os.path.join(self.storage, self.META_FILENAME)
        if not os.path.exists(meta_path):
            # Create META file
            meta = OrderedDict()
            meta[&#39;INFO&#39;] = OrderedDict()
            meta[&#39;INFO&#39;][&#39;owner&#39;] = &#34;&#34;
            meta[&#39;INFO&#39;][&#39;description&#39;] = &#34;&#34;
            meta[&#39;INFO&#39;][&#39;created&#39;] = datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S%Z&#39;)
        else:
            meta = toml.load(meta_path, OrderedDict)
        # Update DB INFO
        total_cnt = meta[&#39;INFO&#39;].get(&#39;number_of_certificates&#39;, 0)
        meta[&#39;INFO&#39;][&#39;number_of_certificates&#39;] = total_cnt + inserted - deleted
        meta[&#39;INFO&#39;][&#39;last_commit&#39;] = datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S%Z&#39;)
        # Append commit HISTORY
        if &#39;HISTORY&#39; not in meta:
            meta[&#39;HISTORY&#39;] = OrderedDict()
        commit_nr = str(len(meta[&#39;HISTORY&#39;]) + 1)
        meta[&#39;HISTORY&#39;][commit_nr] = OrderedDict()
        meta[&#39;HISTORY&#39;][commit_nr][&#39;date&#39;] = meta[&#39;INFO&#39;][&#39;last_commit&#39;]
        meta[&#39;HISTORY&#39;][commit_nr][&#39;inserted&#39;] = inserted
        meta[&#39;HISTORY&#39;][commit_nr][&#39;deleted&#39;] = deleted

        log.debug(meta)
        with open(meta_path, &#39;w&#39;) as meta_file:
            toml.dump(meta, meta_file)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cevast.certdb.cert_db.CertDB" href="cert_db.html#cevast.certdb.cert_db.CertDB">CertDB</a></li>
<li><a title="cevast.certdb.cert_file_db.CertFileDBReadOnly" href="cert_file_db.html#cevast.certdb.cert_file_db.CertFileDBReadOnly">CertFileDBReadOnly</a></li>
<li><a title="cevast.certdb.cert_db.CertDBReadOnly" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly">CertDBReadOnly</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="cevast.certdb.CertFileDB.delete_certs"><code class="name flex">
<span>def <span class="ident">delete_certs</span></span>(<span>block_archive: str, certs: set) -> int</span>
</code></dt>
<dd>
<div class="desc"><p>Delete persisted certificates from block archive</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def delete_certs(block_archive: str, certs: set) -&gt; int:
    &#34;&#34;&#34;Delete persisted certificates from block archive&#34;&#34;&#34;
    cnt_deleted = 0
    if certs and os.path.exists(block_archive):
        deleted_all = True
        new_block_archive = block_archive + &#39;_new&#39;
        with ZipFile(block_archive, &#39;r&#39;, ZIP_STORED) as zin,\
             ZipFile(new_block_archive, &#39;w&#39;, ZIP_STORED) as zout:
            for name in zin.namelist():
                if os.path.splitext(name)[0] not in certs:
                    zout.writestr(name, zin.read(name))
                    deleted_all = False
                else:
                    cnt_deleted += 1
        # Remove the original zipfile and replace it with new one
        os.remove(block_archive)
        if deleted_all:
            # Delete the empty zipfile
            os.remove(new_block_archive)
        else:
            os.rename(new_block_archive, block_archive)

    log.debug(&#39;Deleted %d certificates from block %s&#39;, cnt_deleted, block_archive)
    return cnt_deleted</code></pre>
</details>
</dd>
<dt id="cevast.certdb.CertFileDB.persist_certs"><code class="name flex">
<span>def <span class="ident">persist_certs</span></span>(<span>block_path: str, block_archive: str, certs: set) -> int</span>
</code></dt>
<dd>
<div class="desc"><p>Persist certificates to block archive</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def persist_certs(block_path: str, block_archive: str, certs: set) -&gt; int:
    &#34;&#34;&#34;Persist certificates to block archive&#34;&#34;&#34;
    if not certs:
        log.debug(&#39;Nothing to insert from block %s&#39;, block_path)
        return 0
    cnt_inserted = 0
    if os.path.exists(block_archive):
        append = True
        log.debug(&#39;Appending to archive: %s&#39;, block_archive)
    else:
        append = False
        log.debug(&#39;Creating archive: %s&#39;, block_archive)

    # TODO compare performance for higher compresslevel
    with ZipFile(block_archive, &#34;a&#34; if append else &#34;w&#34;, ZIP_STORED) as zout:
        if append:
            persisted_certs = zout.namelist()

        for cert in certs:
            cert_file = block_path + cert
            if append and cert in persisted_certs:
                pass  # do not insert duplicates
            else:
                zout.write(cert_file, cert)
                cnt_inserted += 1
            os.remove(cert_file)

    log.debug(&#39;Persisted %d certificates from block %s&#39;, cnt_inserted, block_path)
    return cnt_inserted</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="cevast.certdb.cert_db.CertDB" href="cert_db.html#cevast.certdb.cert_db.CertDB">CertDB</a></b></code>:
<ul class="hlist">
<li><code><a title="cevast.certdb.cert_db.CertDB.commit" href="cert_db.html#cevast.certdb.cert_db.CertDB.commit">commit</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDB.delete" href="cert_db.html#cevast.certdb.cert_db.CertDB.delete">delete</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDB.exists" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.exists">exists</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDB.exists_all" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.exists_all">exists_all</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDB.export" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.export">export</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDB.get" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.get">get</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDB.insert" href="cert_db.html#cevast.certdb.cert_db.CertDB.insert">insert</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDB.rollback" href="cert_db.html#cevast.certdb.cert_db.CertDB.rollback">rollback</a></code></li>
</ul>
</li>
<li><code><b><a title="cevast.certdb.cert_file_db.CertFileDBReadOnly" href="cert_file_db.html#cevast.certdb.cert_file_db.CertFileDBReadOnly">CertFileDBReadOnly</a></b></code>:
<ul class="hlist">
<li><code><a title="cevast.certdb.cert_file_db.CertFileDBReadOnly.setup" href="cert_file_db.html#cevast.certdb.cert_file_db.CertFileDBReadOnly.setup">setup</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="cevast.certdb.CertFileDBReadOnly"><code class="flex name class">
<span>class <span class="ident">CertFileDBReadOnly</span></span>
<span>(</span><span>storage: str)</span>
</code></dt>
<dd>
<div class="desc"><p>CertDBReadOnly interface implementation which uses files
and a file system properties as a storage mechanism.</p>
<p><code>storage</code> is path to the database storage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CertFileDBReadOnly(CertDBReadOnly):
    &#34;&#34;&#34;
    CertDBReadOnly interface implementation which uses files
    and a file system properties as a storage mechanism.

    `storage` is path to the database storage.
    &#34;&#34;&#34;

    CONF_FILENAME = &#39;CertFileDB.toml&#39;
    META_FILENAME = &#39;.CertFileDB-META.toml&#39;

    @staticmethod
    def setup(storage_path: str, structure_level: int = 2, cert_format: str = &#39;PEM&#39;,
              desc: str = &#39;CertFileDB&#39;, owner: str = &#39;&#39;, maintain_info: bool = True) -&gt; None:
        &#34;&#34;&#34;
        Setup CertFileDB storage directory with the given parameters.
        `storage_path` is path to the database root directory,
        `structure_level` is hierarchy level of certificate blocks,
        `cert_format` is used format of stored certificates,
        `desc` is database description,
        `owner` is database owner,
        `maintain_info` is flag whether to maintain META file or not.

        Directory, configuration and META file is created.
        Raise ValueError for wrong parameters or if DB already exists.
        &#34;&#34;&#34;
        storage_path = os.path.abspath(storage_path)
        config_path = os.path.join(storage_path, CertFileDB.CONF_FILENAME)
        meta_path = os.path.join(storage_path, CertFileDB.META_FILENAME)
        if os.path.exists(config_path):
            raise ValueError(&#39;CertFileDB already exists&#39;)
        if not isinstance(structure_level, int):
            raise ValueError(&#39;structure_level must be an integer&#39;)
        os.makedirs(storage_path, exist_ok=True)
        # Create configuration file
        config = OrderedDict()
        config[&#39;PARAMETERS&#39;] = OrderedDict()
        config[&#39;PARAMETERS&#39;][&#39;storage&#39;] = storage_path
        config[&#39;PARAMETERS&#39;][&#39;structure_level&#39;] = structure_level
        config[&#39;PARAMETERS&#39;][&#39;cert_format&#39;] = cert_format
        config[&#39;PARAMETERS&#39;][&#39;compression_method&#39;] = &#39;ZIP_STORED&#39;
        config[&#39;PARAMETERS&#39;][&#39;maintain_info&#39;] = maintain_info
        with open(config_path, &#39;w&#39;) as cfg_file:
            toml.dump(config, cfg_file)
        # Create META file
        meta = OrderedDict()
        meta[&#39;INFO&#39;] = OrderedDict()
        meta[&#39;INFO&#39;][&#39;owner&#39;] = owner
        meta[&#39;INFO&#39;][&#39;description&#39;] = desc
        meta[&#39;INFO&#39;][&#39;created&#39;] = datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S%Z&#39;)
        with open(meta_path, &#39;w&#39;) as meta_file:
            toml.dump(meta, meta_file)

        log.info(&#39;CertFileDB was setup:\n%s&#39;, config)

    def __init__(self, storage: str):
        # Get config
        try:
            config_path = os.path.join(os.path.abspath(storage), self.CONF_FILENAME)
            self.storage = os.path.abspath(storage)
            config = toml.load(config_path)
            self._params = config[&#39;PARAMETERS&#39;]
            log.info(&#39;Found CertFileDB &lt;%s&gt;:\n%s&#39;, config_path, config)
        except FileNotFoundError:
            raise ValueError(&#39;CertFileDB &lt;{}&gt; does not exists -&gt; call CertFileDB.setup() first&#39;.format(config_path))
        # Init DB instance
        log.info(&#39;Initializing %s transaction...&#39;, self.__class__.__name__)
        # Set maintaining all known certificate IDs for better EXISTS performance
        self._cache: set = set()
        # Pre-compute index used for block_id
        self._block_id_index = self._params[&#39;structure_level&#39;] + 1
        # Redefine _get_block_id method for special case with structure_level = 0
        if self._params[&#39;structure_level&#39;] == 0:
            fixed_block_id = os.path.basename(self.storage)
            self._get_block_id = lambda _: fixed_block_id

    def get(self, cert_id: str) -&gt; str:
        # Check if certificate exists
        try:
            zip_file = self._get_block_archive(cert_id)
            with ZipFile(zip_file, &#39;r&#39;, ZIP_STORED) as z_obj:
                with z_obj.open(cert_id) as cert:
                    log.debug(&#39;&lt;%s&gt; found persisted in zip &lt;%s&gt;&#39;, cert_id, zip_file)
                    return cert.read().decode(&#39;utf-8&#39;)
        except (KeyError, FileNotFoundError):
            pass

        log.info(&#39;&lt;%s&gt; not found&#39;, cert_id)
        if cert_id in self._cache:
            self._cache.clear()  # Cache seems to be invalidated, so clear it
        raise CertNotAvailableError(cert_id)

    def export(self, cert_id: str, target_dir: str, copy_if_exists: bool = True) -&gt; str:
        # Check if certificate exists persisted
        try:
            zip_file = self._get_block_archive(cert_id)
            with ZipFile(zip_file, &#39;r&#39;, ZIP_STORED) as z_obj:
                zipinfo = z_obj.getinfo(cert_id)
                zipinfo.filename = make_PEM_filename(cert_id)
                z_obj.extract(zipinfo, target_dir)
                log.debug(&#39;&lt;%s&gt; found persisted in zip &lt;%s&gt;&#39;, cert_id, zip_file)
                return os.path.join(target_dir, make_PEM_filename(cert_id))
        except (KeyError, FileNotFoundError):
            pass

        log.info(&#39;&lt;%s&gt; not found&#39;, cert_id)
        if cert_id in self._cache:
            self._cache.clear()  # Cache seems to be invalidated, so clear it
        raise CertNotAvailableError(cert_id)

    def exists(self, cert_id: str) -&gt; bool:
        # Check cache first
        if cert_id in self._cache:
            log.debug(&#39;&lt;%s&gt; found in cache&#39;, cert_id)
            return True
        # Check if certificate exists persisted
        try:
            zip_file = self._get_block_archive(cert_id)
            with ZipFile(zip_file, &#39;r&#39;, ZIP_STORED) as z_obj:
                z_obj.getinfo(cert_id)
                log.debug(&#39;&lt;%s&gt; exists persisted &lt;%s&gt;&#39;, cert_id, zip_file)
                self._cache.add(cert_id)
                return True
        except (KeyError, FileNotFoundError):
            pass

        log.debug(&#39;&lt;%s&gt; does not exist&#39;, cert_id)
        return False

    def exists_all(self, cert_ids: list) -&gt; bool:
        for cert_id in cert_ids:
            if not self.exists(cert_id):
                return False

        return True

    def _get_block_path(self, cert_or_block_id: str) -&gt; str:
        &#34;&#34;&#34;Return full block path of certificate or block id&#34;&#34;&#34;
        paths = [cert_or_block_id[: 2 + i] for i in range(self._params[&#39;structure_level&#39;])]
        return &#34;/&#34;.join([self._params[&#39;storage&#39;]] + paths) + &#39;/&#39;

    def _get_block_id(self, cert_id: str) -&gt; str:  # pylint: disable=E0202
        return cert_id[: self._block_id_index]

    def _get_block_archive(self, cert_or_block_id: str) -&gt; str:
        block_path = self._get_block_path(cert_or_block_id)
        return block_path + self._get_block_id(cert_or_block_id) + &#39;.zip&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cevast.certdb.cert_db.CertDBReadOnly" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly">CertDBReadOnly</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="cevast.certdb.cert_file_db.CertFileDB" href="cert_file_db.html#cevast.certdb.cert_file_db.CertFileDB">CertFileDB</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="cevast.certdb.CertFileDBReadOnly.CONF_FILENAME"><code class="name">var <span class="ident">CONF_FILENAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cevast.certdb.CertFileDBReadOnly.META_FILENAME"><code class="name">var <span class="ident">META_FILENAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="cevast.certdb.CertFileDBReadOnly.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>storage_path: str, structure_level: int = 2, cert_format: str = 'PEM', desc: str = 'CertFileDB', owner: str = '', maintain_info: bool = True) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Setup CertFileDB storage directory with the given parameters.
<code>storage_path</code> is path to the database root directory,
<code>structure_level</code> is hierarchy level of certificate blocks,
<code>cert_format</code> is used format of stored certificates,
<code>desc</code> is database description,
<code>owner</code> is database owner,
<code>maintain_info</code> is flag whether to maintain META file or not.</p>
<p>Directory, configuration and META file is created.
Raise ValueError for wrong parameters or if DB already exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def setup(storage_path: str, structure_level: int = 2, cert_format: str = &#39;PEM&#39;,
          desc: str = &#39;CertFileDB&#39;, owner: str = &#39;&#39;, maintain_info: bool = True) -&gt; None:
    &#34;&#34;&#34;
    Setup CertFileDB storage directory with the given parameters.
    `storage_path` is path to the database root directory,
    `structure_level` is hierarchy level of certificate blocks,
    `cert_format` is used format of stored certificates,
    `desc` is database description,
    `owner` is database owner,
    `maintain_info` is flag whether to maintain META file or not.

    Directory, configuration and META file is created.
    Raise ValueError for wrong parameters or if DB already exists.
    &#34;&#34;&#34;
    storage_path = os.path.abspath(storage_path)
    config_path = os.path.join(storage_path, CertFileDB.CONF_FILENAME)
    meta_path = os.path.join(storage_path, CertFileDB.META_FILENAME)
    if os.path.exists(config_path):
        raise ValueError(&#39;CertFileDB already exists&#39;)
    if not isinstance(structure_level, int):
        raise ValueError(&#39;structure_level must be an integer&#39;)
    os.makedirs(storage_path, exist_ok=True)
    # Create configuration file
    config = OrderedDict()
    config[&#39;PARAMETERS&#39;] = OrderedDict()
    config[&#39;PARAMETERS&#39;][&#39;storage&#39;] = storage_path
    config[&#39;PARAMETERS&#39;][&#39;structure_level&#39;] = structure_level
    config[&#39;PARAMETERS&#39;][&#39;cert_format&#39;] = cert_format
    config[&#39;PARAMETERS&#39;][&#39;compression_method&#39;] = &#39;ZIP_STORED&#39;
    config[&#39;PARAMETERS&#39;][&#39;maintain_info&#39;] = maintain_info
    with open(config_path, &#39;w&#39;) as cfg_file:
        toml.dump(config, cfg_file)
    # Create META file
    meta = OrderedDict()
    meta[&#39;INFO&#39;] = OrderedDict()
    meta[&#39;INFO&#39;][&#39;owner&#39;] = owner
    meta[&#39;INFO&#39;][&#39;description&#39;] = desc
    meta[&#39;INFO&#39;][&#39;created&#39;] = datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S%Z&#39;)
    with open(meta_path, &#39;w&#39;) as meta_file:
        toml.dump(meta, meta_file)

    log.info(&#39;CertFileDB was setup:\n%s&#39;, config)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="cevast.certdb.cert_db.CertDBReadOnly" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly">CertDBReadOnly</a></b></code>:
<ul class="hlist">
<li><code><a title="cevast.certdb.cert_db.CertDBReadOnly.exists" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.exists">exists</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDBReadOnly.exists_all" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.exists_all">exists_all</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDBReadOnly.export" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.export">export</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDBReadOnly.get" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.get">get</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="cevast.certdb.CertInvalidError"><code class="flex name class">
<span>class <span class="ident">CertInvalidError</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>Raised when the certificate has an invalid identifier or a structure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CertInvalidError(ValueError):
    &#34;&#34;&#34;Raised when the certificate has an invalid identifier or a structure&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="cevast.certdb.CertNotAvailableError"><code class="flex name class">
<span>class <span class="ident">CertNotAvailableError</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>Raised when the certificate is not available in database</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CertNotAvailableError(Exception):
    &#34;&#34;&#34;Raised when the certificate is not available in database&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="cevast.certdb.CompositeCertDB"><code class="flex name class">
<span>class <span class="ident">CompositeCertDB</span></span>
</code></dt>
<dd>
<div class="desc"><p>Composite manager of CertDB components.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CompositeCertDB(CertDB, CompositeCertDBReadOnly):
    &#34;&#34;&#34;
    Composite manager of CertDB components.
    &#34;&#34;&#34;

    def __init__(self):  # pylint: disable=W0231
        log.info(&#39;Initializing CompositeCertDB composite manager...&#39;)
        # List managing all registered CertDB components
        self._children: List(Union[CertDB, CertDBReadOnly]) = []
        # List managing all registered CertDBReadOnly components
        self.__io_allowed: List(CertDB) = []

    def register(self, certdb: Union[CertDB, CertDBReadOnly]) -&gt; None:
        if certdb not in self._children:
            self._children.append(certdb)
            if isinstance(certdb, CertDB):
                self.__io_allowed.append(certdb)

    def unregister(self, certdb: Union[CertDB, CertDBReadOnly]) -&gt; None:
        try:
            self._children.remove(certdb)
        except ValueError:
            pass
        try:
            self.__io_allowed.remove(certdb)
        except ValueError:
            pass

    def insert(self, cert_id: str, cert: str) -&gt; None:
        for child in self.__io_allowed:
            child.insert(cert_id, cert)

    def delete(self, cert_id: str) -&gt; None:
        for child in self.__io_allowed:
            child.delete(cert_id)

    def rollback(self) -&gt; None:
        for child in self.__io_allowed:
            child.rollback()

    def commit(self) -&gt; Tuple[int, int]:
        cnt_inserted, cnt_deleted = 0, 0
        for child in self.__io_allowed:
            cnt_inserted, cnt_deleted = child.commit()
        return cnt_inserted, cnt_deleted</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cevast.certdb.cert_db.CertDB" href="cert_db.html#cevast.certdb.cert_db.CertDB">CertDB</a></li>
<li><a title="cevast.certdb.composite_cert_db.CompositeCertDBReadOnly" href="composite_cert_db.html#cevast.certdb.composite_cert_db.CompositeCertDBReadOnly">CompositeCertDBReadOnly</a></li>
<li><a title="cevast.certdb.cert_db.CertDBReadOnly" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly">CertDBReadOnly</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cevast.certdb.CompositeCertDB.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>self, certdb: <a title="cevast.certdb.cert_db.CertDBReadOnly" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly">CertDBReadOnly</a>) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Register a virtual subclass of an ABC.</p>
<p>Returns the subclass, to allow usage as a class decorator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register(self, certdb: Union[CertDB, CertDBReadOnly]) -&gt; None:
    if certdb not in self._children:
        self._children.append(certdb)
        if isinstance(certdb, CertDB):
            self.__io_allowed.append(certdb)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="cevast.certdb.cert_db.CertDB" href="cert_db.html#cevast.certdb.cert_db.CertDB">CertDB</a></b></code>:
<ul class="hlist">
<li><code><a title="cevast.certdb.cert_db.CertDB.commit" href="cert_db.html#cevast.certdb.cert_db.CertDB.commit">commit</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDB.delete" href="cert_db.html#cevast.certdb.cert_db.CertDB.delete">delete</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDB.exists" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.exists">exists</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDB.exists_all" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.exists_all">exists_all</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDB.export" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.export">export</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDB.get" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.get">get</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDB.insert" href="cert_db.html#cevast.certdb.cert_db.CertDB.insert">insert</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDB.rollback" href="cert_db.html#cevast.certdb.cert_db.CertDB.rollback">rollback</a></code></li>
</ul>
</li>
<li><code><b><a title="cevast.certdb.composite_cert_db.CompositeCertDBReadOnly" href="composite_cert_db.html#cevast.certdb.composite_cert_db.CompositeCertDBReadOnly">CompositeCertDBReadOnly</a></b></code>:
<ul class="hlist">
<li><code><a title="cevast.certdb.composite_cert_db.CompositeCertDBReadOnly.unregister" href="composite_cert_db.html#cevast.certdb.composite_cert_db.CompositeCertDBReadOnly.unregister">unregister</a></code></li>
</ul>
</li>
<li><code><b><a title="cevast.certdb.composite_cert_db.CompositeCertDBReadOnly" href="composite_cert_db.html#cevast.certdb.composite_cert_db.CompositeCertDBReadOnly">CompositeCertDBReadOnly</a></b></code>:
<ul class="hlist">
<li><code><a title="cevast.certdb.composite_cert_db.CompositeCertDBReadOnly.is_registered" href="composite_cert_db.html#cevast.certdb.composite_cert_db.CompositeCertDBReadOnly.is_registered">is_registered</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="cevast.certdb.CompositeCertDBReadOnly"><code class="flex name class">
<span>class <span class="ident">CompositeCertDBReadOnly</span></span>
</code></dt>
<dd>
<div class="desc"><p>Composite manager of CertDBReadOnly components.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CompositeCertDBReadOnly(CertDBReadOnly):
    &#34;&#34;&#34;
    Composite manager of CertDBReadOnly components.
    &#34;&#34;&#34;

    def __init__(self):
        log.info(&#39;Initializing CompositeCertDBReadOnly composite manager...&#39;)
        # List managing all registered CertDBReadOnly components
        self._children: List(CertDBReadOnly) = []

    def register(self, certdb: CertDBReadOnly) -&gt; None:
        &#34;&#34;&#34;Add component object to the composite manager.&#34;&#34;&#34;
        if certdb not in self._children:
            self._children.append(certdb)

    def unregister(self, certdb: CertDBReadOnly) -&gt; None:
        &#34;&#34;&#34;Remove component object from the composite manager.&#34;&#34;&#34;
        try:
            self._children.remove(certdb)
        except ValueError:
            pass

    def is_registered(self, certdb: CertDBReadOnly) -&gt; bool:
        &#34;&#34;&#34;Test if component object is registered in the composite manager.&#34;&#34;&#34;
        return certdb in self._children

    def get(self, cert_id: str) -&gt; str:
        for child in self._children:
            try:
                return child.get(cert_id)
            except CertNotAvailableError:
                pass
        raise CertNotAvailableError

    def export(self, cert_id: str, target_dir: str, copy_if_exists: bool = True) -&gt; str:
        for child in self._children:
            try:
                return child.export(cert_id, target_dir, copy_if_exists)
            except CertNotAvailableError:
                pass
        raise CertNotAvailableError

    def exists(self, cert_id: str) -&gt; bool:
        for child in self._children:
            if child.exists(cert_id):
                return True
        return False

    def exists_all(self, cert_ids: list) -&gt; bool:
        for cert_id in cert_ids:
            for child in self._children:
                if child.exists(cert_id):
                    break
            else:
                return False  # only executed if the inner loop did NOT break
            pass  # only executed if the inner loop DID break

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cevast.certdb.cert_db.CertDBReadOnly" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly">CertDBReadOnly</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="cevast.certdb.composite_cert_db.CompositeCertDB" href="composite_cert_db.html#cevast.certdb.composite_cert_db.CompositeCertDB">CompositeCertDB</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cevast.certdb.CompositeCertDBReadOnly.is_registered"><code class="name flex">
<span>def <span class="ident">is_registered</span></span>(<span>self, certdb: <a title="cevast.certdb.cert_db.CertDBReadOnly" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly">CertDBReadOnly</a>) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Test if component object is registered in the composite manager.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_registered(self, certdb: CertDBReadOnly) -&gt; bool:
    &#34;&#34;&#34;Test if component object is registered in the composite manager.&#34;&#34;&#34;
    return certdb in self._children</code></pre>
</details>
</dd>
<dt id="cevast.certdb.CompositeCertDBReadOnly.register"><code class="name flex">
<span>def <span class="ident">register</span></span>(<span>self, certdb: <a title="cevast.certdb.cert_db.CertDBReadOnly" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly">CertDBReadOnly</a>) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add component object to the composite manager.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register(self, certdb: CertDBReadOnly) -&gt; None:
    &#34;&#34;&#34;Add component object to the composite manager.&#34;&#34;&#34;
    if certdb not in self._children:
        self._children.append(certdb)</code></pre>
</details>
</dd>
<dt id="cevast.certdb.CompositeCertDBReadOnly.unregister"><code class="name flex">
<span>def <span class="ident">unregister</span></span>(<span>self, certdb: <a title="cevast.certdb.cert_db.CertDBReadOnly" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly">CertDBReadOnly</a>) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Remove component object from the composite manager.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unregister(self, certdb: CertDBReadOnly) -&gt; None:
    &#34;&#34;&#34;Remove component object from the composite manager.&#34;&#34;&#34;
    try:
        self._children.remove(certdb)
    except ValueError:
        pass</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="cevast.certdb.cert_db.CertDBReadOnly" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly">CertDBReadOnly</a></b></code>:
<ul class="hlist">
<li><code><a title="cevast.certdb.cert_db.CertDBReadOnly.exists" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.exists">exists</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDBReadOnly.exists_all" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.exists_all">exists_all</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDBReadOnly.export" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.export">export</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDBReadOnly.get" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.get">get</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cevast" href="../index.html">cevast</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="cevast.certdb.cert_db" href="cert_db.html">cevast.certdb.cert_db</a></code></li>
<li><code><a title="cevast.certdb.cert_file_db" href="cert_file_db.html">cevast.certdb.cert_file_db</a></code></li>
<li><code><a title="cevast.certdb.cli" href="cli.html">cevast.certdb.cli</a></code></li>
<li><code><a title="cevast.certdb.composite_cert_db" href="composite_cert_db.html">cevast.certdb.composite_cert_db</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cevast.certdb.CertDB" href="#cevast.certdb.CertDB">CertDB</a></code></h4>
<ul class="">
<li><code><a title="cevast.certdb.CertDB.commit" href="#cevast.certdb.CertDB.commit">commit</a></code></li>
<li><code><a title="cevast.certdb.CertDB.delete" href="#cevast.certdb.CertDB.delete">delete</a></code></li>
<li><code><a title="cevast.certdb.CertDB.insert" href="#cevast.certdb.CertDB.insert">insert</a></code></li>
<li><code><a title="cevast.certdb.CertDB.rollback" href="#cevast.certdb.CertDB.rollback">rollback</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cevast.certdb.CertDBReadOnly" href="#cevast.certdb.CertDBReadOnly">CertDBReadOnly</a></code></h4>
<ul class="">
<li><code><a title="cevast.certdb.CertDBReadOnly.exists" href="#cevast.certdb.CertDBReadOnly.exists">exists</a></code></li>
<li><code><a title="cevast.certdb.CertDBReadOnly.exists_all" href="#cevast.certdb.CertDBReadOnly.exists_all">exists_all</a></code></li>
<li><code><a title="cevast.certdb.CertDBReadOnly.export" href="#cevast.certdb.CertDBReadOnly.export">export</a></code></li>
<li><code><a title="cevast.certdb.CertDBReadOnly.get" href="#cevast.certdb.CertDBReadOnly.get">get</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cevast.certdb.CertFileDB" href="#cevast.certdb.CertFileDB">CertFileDB</a></code></h4>
<ul class="">
<li><code><a title="cevast.certdb.CertFileDB.delete_certs" href="#cevast.certdb.CertFileDB.delete_certs">delete_certs</a></code></li>
<li><code><a title="cevast.certdb.CertFileDB.persist_certs" href="#cevast.certdb.CertFileDB.persist_certs">persist_certs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cevast.certdb.CertFileDBReadOnly" href="#cevast.certdb.CertFileDBReadOnly">CertFileDBReadOnly</a></code></h4>
<ul class="">
<li><code><a title="cevast.certdb.CertFileDBReadOnly.CONF_FILENAME" href="#cevast.certdb.CertFileDBReadOnly.CONF_FILENAME">CONF_FILENAME</a></code></li>
<li><code><a title="cevast.certdb.CertFileDBReadOnly.META_FILENAME" href="#cevast.certdb.CertFileDBReadOnly.META_FILENAME">META_FILENAME</a></code></li>
<li><code><a title="cevast.certdb.CertFileDBReadOnly.setup" href="#cevast.certdb.CertFileDBReadOnly.setup">setup</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cevast.certdb.CertInvalidError" href="#cevast.certdb.CertInvalidError">CertInvalidError</a></code></h4>
</li>
<li>
<h4><code><a title="cevast.certdb.CertNotAvailableError" href="#cevast.certdb.CertNotAvailableError">CertNotAvailableError</a></code></h4>
</li>
<li>
<h4><code><a title="cevast.certdb.CompositeCertDB" href="#cevast.certdb.CompositeCertDB">CompositeCertDB</a></code></h4>
<ul class="">
<li><code><a title="cevast.certdb.CompositeCertDB.register" href="#cevast.certdb.CompositeCertDB.register">register</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cevast.certdb.CompositeCertDBReadOnly" href="#cevast.certdb.CompositeCertDBReadOnly">CompositeCertDBReadOnly</a></code></h4>
<ul class="">
<li><code><a title="cevast.certdb.CompositeCertDBReadOnly.is_registered" href="#cevast.certdb.CompositeCertDBReadOnly.is_registered">is_registered</a></code></li>
<li><code><a title="cevast.certdb.CompositeCertDBReadOnly.register" href="#cevast.certdb.CompositeCertDBReadOnly.register">register</a></code></li>
<li><code><a title="cevast.certdb.CompositeCertDBReadOnly.unregister" href="#cevast.certdb.CompositeCertDBReadOnly.unregister">unregister</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>