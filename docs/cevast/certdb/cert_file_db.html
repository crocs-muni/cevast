<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>cevast.certdb.cert_file_db API documentation</title>
<meta name="description" content="This module contains implementation of CertFileDB …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cevast.certdb.cert_file_db</code></h1>
</header>
<section id="section-intro">
<p>This module contains implementation of CertFileDB</p>
<pre><code>CertFileDB is a simple local database implementing CertDB interface that
uses files and a file system properties as a storage mechanism.
</code></pre>
<p>Storage structure on the file system:
storage/
- path to the storage given as an initial parameter to CertFileDB containing
hierarchy of certificate blocks (group of certificates with equal prefix)
- id[2]/
- first 2 characters of certificate ID (fingerprint) make block (e.g. 1a/)
- id[3].zip
- first 2 characters of certificate ID (fingerprint) (e.g. 1af.zip)
- &hellip;
- &hellip;
- .CertFileDB.toml
- CertFileDB configuration file
- .CertFileDB-META.toml
- CertFileDB meta-information file</p>
<p>.CertFileDB.toml example:
[PARAMETERS]
storage = "/var/tmp/cevast_storage"
structure_level = 2
cert_format = "PEM"
compression_method = "ZIP_DEFLATED"
maintain_info = True</p>
<p>.CertFileDB-META.toml example:
[INFO]
owner = "cevast"
description = "Certificate storage for Cevast tool"
created = "2020-02-30 14:23:18"
number_of_certificates = 2013562
last_commit = "2020-05-30 22:44:48"</p>
<p>[HISTORY]
a = 1
b = 2
"2020-05-30 22:44:48" = "added=5; removed=1;"</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module contains implementation of CertFileDB

    CertFileDB is a simple local database implementing CertDB interface that
    uses files and a file system properties as a storage mechanism.

Storage structure on the file system:
storage/             - path to the storage given as an initial parameter to CertFileDB containing
                       hierarchy of certificate blocks (group of certificates with equal prefix)
    - id[2]/         - first 2 characters of certificate ID (fingerprint) make block (e.g. 1a/)
        - id[3].zip  - first 2 characters of certificate ID (fingerprint) (e.g. 1af.zip)
        - ...
    - ...
    - .CertFileDB.toml       - CertFileDB configuration file
    - .CertFileDB-META.toml  - CertFileDB meta-information file

.CertFileDB.toml example:
[PARAMETERS]
storage = &#34;/var/tmp/cevast_storage&#34;
structure_level = 2
cert_format = &#34;PEM&#34;
compression_method = &#34;ZIP_DEFLATED&#34;
maintain_info = True

.CertFileDB-META.toml example:
[INFO]
owner = &#34;cevast&#34;
description = &#34;Certificate storage for Cevast tool&#34;
created = &#34;2020-02-30 14:23:18&#34;
number_of_certificates = 2013562
last_commit = &#34;2020-05-30 22:44:48&#34;

[HISTORY]
a = 1
b = 2
&#34;2020-05-30 22:44:48&#34; = &#34;added=5; removed=1;&#34;
&#34;&#34;&#34;

import os
import shutil
import logging
import multiprocessing as mp
from typing import Tuple
from datetime import datetime
from collections import OrderedDict
from zipfile import ZipFile, ZIP_DEFLATED
import toml
from cevast.utils import make_PEM_filename, remove_empty_folders
from cevast.certdb.cert_db import (
    CertDB,
    CertDBReadOnly,
    CertNotAvailableError,
    CertInvalidError,
)

__author__ = &#39;Radim Podola&#39;

log = logging.getLogger(__name__)

# TODO parallel transaction checking - mmap
# - open transaction Flag - will be set by INSERT/REMOVE/ROLLBACK/COMMIT -&gt; OpenTransaction/CloseTransaction decorator ??
# - allow_more_transaction Flag that will not raise DBInUse error??
# - or reserve block?? mmap vector of flags (up to 256 els) - each element is root block
# TODO make persist_and_clear_storage/clear_storage utility method that will not use transaction data


class CertFileDBReadOnly(CertDBReadOnly):
    &#34;&#34;&#34;
    CertDBReadOnly interface implementation which uses files
    and a file system properties as a storage mechanism.

    `storage` is path to the database storage.
    &#34;&#34;&#34;

    CONF_FILENAME = &#39;CertFileDB.toml&#39;
    META_FILENAME = &#39;.CertFileDB-META.toml&#39;

    @staticmethod
    def setup(storage_path: str, structure_level: int = 2, cert_format: str = &#39;PEM&#39;,
              desc: str = &#39;CertFileDB&#39;, owner: str = &#39;&#39;, maintain_info: bool = True) -&gt; None:
        &#34;&#34;&#34;
        Setup CertFileDB storage directory with the given parameters.
        Directory, configuration and META file is created.
        Raise ValueError for wrong parameters or if DB already exists.
        &#34;&#34;&#34;
        storage_path = os.path.abspath(storage_path)
        config_path = os.path.join(storage_path, CertFileDB.CONF_FILENAME)
        meta_path = os.path.join(storage_path, CertFileDB.META_FILENAME)
        if os.path.exists(config_path):
            raise ValueError(&#39;CertFileDB already exists&#39;)
        if not isinstance(structure_level, int):
            raise ValueError(&#39;structure_level must be an integer&#39;)
        os.makedirs(storage_path, exist_ok=True)
        # Create configuration file
        config = OrderedDict()
        config[&#39;PARAMETERS&#39;] = OrderedDict()
        config[&#39;PARAMETERS&#39;][&#39;storage&#39;] = storage_path
        config[&#39;PARAMETERS&#39;][&#39;structure_level&#39;] = structure_level
        config[&#39;PARAMETERS&#39;][&#39;cert_format&#39;] = cert_format
        config[&#39;PARAMETERS&#39;][&#39;compression_method&#39;] = &#39;ZIP_DEFLATED&#39;
        config[&#39;PARAMETERS&#39;][&#39;maintain_info&#39;] = maintain_info
        with open(config_path, &#39;w&#39;) as cfg_file:
            toml.dump(config, cfg_file)
        # Create META file
        meta = OrderedDict()
        meta[&#39;INFO&#39;] = OrderedDict()
        meta[&#39;INFO&#39;][&#39;owner&#39;] = owner
        meta[&#39;INFO&#39;][&#39;description&#39;] = desc
        meta[&#39;INFO&#39;][&#39;created&#39;] = datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S%Z&#39;)
        with open(meta_path, &#39;w&#39;) as meta_file:
            toml.dump(meta, meta_file)

        log.info(&#39;CertFileDB was setup:\n%s&#39;, config)

    def __init__(self, storage: str):
        # Get config
        try:
            config_path = os.path.join(os.path.abspath(storage), self.CONF_FILENAME)
            self.storage = os.path.abspath(storage)
            config = toml.load(config_path)
            self._params = config[&#39;PARAMETERS&#39;]
            log.info(&#39;Found CertFileDB &lt;%s&gt;:\n%s&#39;, config_path, config)
        except FileNotFoundError:
            raise ValueError(&#39;CertFileDB &lt;{}&gt; does not exists -&gt; call CertFileDB.setup() first&#39;.format(config_path))
        # Init DB instance
        log.info(&#39;Initializing %s transaction...&#39;, self.__class__.__name__)
        # Set maintaining all known certificate IDs for better EXISTS performance
        self._cache: set = set()
        # Pre-compute index used for block_id
        self._block_id_index = self._params[&#39;structure_level&#39;] + 1

    def get(self, cert_id: str) -&gt; str:
        # Check if certificate exists
        try:
            zip_file = self._get_block_archive(cert_id)
            with ZipFile(zip_file, &#39;r&#39;, ZIP_DEFLATED) as z_obj:
                with z_obj.open(cert_id) as cert:
                    log.debug(&#39;&lt;%s&gt; found persisted in zip &lt;%s&gt;&#39;, cert_id, zip_file)
                    return cert.read().decode(&#39;utf-8&#39;)
        except (KeyError, FileNotFoundError):
            pass

        log.info(&#39;&lt;%s&gt; not found&#39;, cert_id)
        if cert_id in self._cache:
            self._cache.clear()  # Cache seems to be invalidated, so clear it
        raise CertNotAvailableError(cert_id)

    def export(self, cert_id: str, target_dir: str, copy_if_exists: bool = True) -&gt; str:
        # Check if certificate exists persisted
        try:
            zip_file = self._get_block_archive(cert_id)
            with ZipFile(zip_file, &#39;r&#39;, ZIP_DEFLATED) as z_obj:
                zipinfo = z_obj.getinfo(cert_id)
                zipinfo.filename = make_PEM_filename(cert_id)
                z_obj.extract(zipinfo, target_dir)
                log.debug(&#39;&lt;%s&gt; found persisted in zip &lt;%s&gt;&#39;, cert_id, zip_file)
                return os.path.join(target_dir, make_PEM_filename(cert_id))
        except (KeyError, FileNotFoundError):
            pass

        log.info(&#39;&lt;%s&gt; not found&#39;, cert_id)
        if cert_id in self._cache:
            self._cache.clear()  # Cache seems to be invalidated, so clear it
        raise CertNotAvailableError(cert_id)

    def exists(self, cert_id: str) -&gt; bool:
        # Check cache first
        if cert_id in self._cache:
            log.debug(&#39;&lt;%s&gt; found in cache&#39;, cert_id)
            return True

        # Check if certificate exists persisted
        try:
            zip_file = self._get_block_archive(cert_id)
            with ZipFile(zip_file, &#39;r&#39;, ZIP_DEFLATED) as z_obj:
                z_obj.getinfo(cert_id)
                log.debug(&#39;&lt;%s&gt; exists persisted &lt;%s&gt;&#39;, cert_id, zip_file)
                self._cache.add(cert_id)
                return True
        except (KeyError, FileNotFoundError):
            pass

        log.debug(&#39;&lt;%s&gt; does not exist&#39;, cert_id)
        return False

    def exists_all(self, cert_ids: list) -&gt; bool:
        for cert_id in cert_ids:
            if not self.exists(cert_id):
                return False

        return True

    def _get_block_path(self, cert_or_block_id: str) -&gt; str:
        &#34;&#34;&#34;Return full block path of certificate or block id&#34;&#34;&#34;
        paths = [cert_or_block_id[: 2 + i] for i in range(self._params[&#39;structure_level&#39;])]
        return &#34;/&#34;.join([self._params[&#39;storage&#39;]] + paths) + &#39;/&#39;

    def _get_block_id(self, cert_id: str) -&gt; str:  # pylint: disable=E0202
        return cert_id[: self._block_id_index]

    def _get_block_archive(self, cert_or_block_id: str) -&gt; str:
        block_path = self._get_block_path(cert_or_block_id)
        return block_path + self._get_block_id(cert_or_block_id) + &#39;.zip&#39;


class CertFileDB(CertDB, CertFileDBReadOnly):
    &#34;&#34;&#34;
    CertDB interface implementation which uses files
    and a file system properties as a storage mechanism.

    `storage` is path to the database storage.
    `cpu_cores` is max number of CPU cores that might be used.
    &#34;&#34;&#34;

    def __init__(self, storage: str, cpu_cores: int = 1):
        CertFileDBReadOnly.__init__(self, storage)
        # Dict containing all inserted certificates grouped in blocks that will be persisted with commit
        self._to_insert: dict = {}
        # Dict containing all deleted certificates grouped in blocks that will be deleted with commit
        self._to_delete: dict = {}
        # Max number of CPU cores that can be used (-1 is max limit by hardware)
        self.__cpu_cores = int(cpu_cores)
        log.info(&#39;Will use %d CPUs&#39;, self.__cpu_cores)
        # Redefine _get_block_id method for special case with structure_level = 0
        if self._params[&#39;structure_level&#39;] == 0:
            fixed_block_id = os.path.basename(storage)
            self._get_block_id = lambda _: fixed_block_id

    def get(self, cert_id: str) -&gt; str:
        # Check if certificate exists as a file (transaction still open)
        if self._is_in_transaction(cert_id, self._to_insert):
            cert_file = self._get_block_path(cert_id) + cert_id
            with open(cert_file, &#39;r&#39;) as source:
                log.debug(&#39;&lt;%s&gt; found in open transaction&#39;, cert_file)
                return source.read()
        # Check if certificate is scheduled for delete
        if self._is_in_transaction(cert_id, self._to_delete):
            log.info(&#39;&lt;%s&gt; was deleted in current transaction&#39;, cert_id)
            raise CertNotAvailableError(cert_id)
        # Check if certificate exists persisted
        return CertFileDBReadOnly.get(self, cert_id)

    def export(self, cert_id: str, target_dir: str, copy_if_exists: bool = True) -&gt; str:
        # Check if certificate exists as a file (transaction still open)
        if self._is_in_transaction(cert_id, self._to_insert):
            cert_src_file = self._get_block_path(cert_id) + cert_id
            log.debug(&#39;&lt;%s&gt; found in open transaction&#39;, cert_src_file)
            if not copy_if_exists:
                return cert_src_file
            # Copy file to the target directory
            cert_trg_file = os.path.join(target_dir, make_PEM_filename(cert_id))
            shutil.copyfile(cert_src_file, cert_trg_file)
            return cert_trg_file
        # Check if certificate is scheduled for delete
        if self._is_in_transaction(cert_id, self._to_delete):
            log.info(&#39;&lt;%s&gt; was deleted in current transaction&#39;, cert_id)
            raise CertNotAvailableError(cert_id)
        # Check if certificate exists persisted
        return CertFileDBReadOnly.export(self, cert_id, target_dir, copy_if_exists)

    def exists(self, cert_id: str) -&gt; bool:
        # Check the open transaction first
        if self._is_in_transaction(cert_id, self._to_insert):
            log.debug(&#39;&lt;%s&gt; exists in open transaction&#39;, cert_id)
            return True
        # Check if certificate is scheduled for delete
        if self._is_in_transaction(cert_id, self._to_delete):
            log.info(&#39;&lt;%s&gt; was deleted in current transaction&#39;, cert_id)
            return False
        # Check if certificate exists persisted
        return CertFileDBReadOnly.exists(self, cert_id)

    def insert(self, cert_id: str, cert: str) -&gt; None:
        if not cert_id or not cert:
            raise CertInvalidError(&#39;cert_id &lt;{}&gt; or cert &lt;{}&gt; invalid&#39;.format(cert_id, cert))
        # Save certificate to temporary file
        block = self._get_block_path(cert_id)
        cert_file = block + cert_id
        if os.path.exists(cert_file):
            log.info(&#39;Certificate %s already exists&#39;, cert_file)
            return

        try:
            with open(cert_file, &#39;w&#39;) as w_file:
                w_file.write(cert)
        except FileNotFoundError:
            os.makedirs(block, exist_ok=True)
            with open(cert_file, &#39;w&#39;) as w_file:
                w_file.write(cert)

        # Add certificate to transaction for insert upon commit
        self._add_to_transaction(cert_id, self._to_insert)
        log.debug(&#39;Certificate %s inserted to block %s&#39;, cert_id, block)

    def delete(self, cert_id: str) -&gt; None:
        if not cert_id:
            raise CertInvalidError(&#39;cert_id &lt;{}&gt; invalid&#39;.format(cert_id))

        if self._is_in_transaction(cert_id, self._to_insert):
            # Immediatelly delete certificate in open transaction if exists
            cert_file = self._get_block_path(cert_id) + cert_id
            self._remove_from_transaction(cert_id, self._to_insert)
            os.remove(cert_file)
            log.debug(&#39;Certificate %s deleted from open transaction&#39;, cert_id)
        else:
            # Add certificate to transaction for delete upon commit
            self._add_to_transaction(cert_id, self._to_delete)
            log.debug(&#39;Certificate %s will be deleted upon commit&#39;, cert_id)

        # Delete certificates from cache
        self._cache.discard(cert_id)

    def rollback(self) -&gt; None:
        log.info(&#39;Rollback started&#39;)
        # Remove uncommitted certificates
        for block, certs in self._to_insert.items():
            block_path = self._get_block_path(block)
            for cert_id in certs:
                os.remove(block_path + cert_id)
        self._to_insert.clear()
        self._to_delete.clear()
        # Clean up empty folders
        remove_empty_folders(self.storage)
        log.info(&#39;Rollback finished&#39;)

    def commit(self) -&gt; Tuple[int, int]:
        log.info(&#39;Commit started&#39;)
        cnt_deleted = 0
        cnt_inserted = 0

        if self.__cpu_cores != 1:
            cnt_inserted, cnt_deleted = self.__commit_async()
        else:
            # Handle delete first because sequence matter
            for block, certs in self._to_delete.items():
                cnt_deleted += CertFileDB.delete_certs(self._get_block_archive(block), certs)
            # Now handle insert
            for block, certs in self._to_insert.items():
                cnt_inserted += CertFileDB.persist_certs(self._get_block_path(block), self._get_block_archive(block), certs)

        self._to_delete.clear()
        self._to_insert.clear()
        log.info(&#39;Deleted %d certificates&#39;, cnt_deleted)
        log.info(&#39;Inserted %d certificates&#39;, cnt_inserted)
        # Clean up empty folders
        remove_empty_folders(self.storage)  # TODO seems not working properly in benchmark
        # Write commit info
        if self._params[&#39;maintain_info&#39;]:
            self.__write_commit_info(cnt_inserted, cnt_deleted)
        log.info(&#39;Commit finished&#39;)
        return cnt_inserted, cnt_deleted

    def __commit_async(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;
        Function acomplishing the same as commit() but with use of multiprocessing.Pool
        of asynchronous workers to persist/delete multiple certificate blocks in parallel.
        &#34;&#34;&#34;
        cnt_deleted = 0
        cnt_inserted = 0
        cpus = self.__cpu_cores if self.__cpu_cores &gt; 0 else None

        pool = mp.Pool(cpus)
        # Handle delete first because sequence matter
        results = []
        for block, certs in self._to_delete.items():
            results.append(pool.apply_async(CertFileDB.delete_certs, args=(self._get_block_archive(block), certs)))
        cnt_deleted = sum([result.get() for result in results])
        # Now handle insert
        results = []
        for block, certs in self._to_insert.items():
            results.append(
                pool.apply_async(
                    CertFileDB.persist_certs, args=(self._get_block_path(block), self._get_block_archive(block), certs)
                )
            )
        cnt_inserted = sum([result.get() for result in results])
        pool.close()
        pool.join()

        return cnt_inserted, cnt_deleted

    # static so I can use it in async pool or find a way hot to use private
    @staticmethod
    def delete_certs(block_archive: str, certs: set) -&gt; int:
        &#34;&#34;&#34;Delete persisted certificates from block archive&#34;&#34;&#34;
        cnt_deleted = 0
        if certs and os.path.exists(block_archive):
            deleted_all = True
            new_block_archive = block_archive + &#39;_new&#39;
            with ZipFile(block_archive, &#39;r&#39;, ZIP_DEFLATED) as zin,\
                 ZipFile(new_block_archive, &#39;w&#39;, ZIP_DEFLATED) as zout:
                for name in zin.namelist():
                    if os.path.splitext(name)[0] not in certs:
                        zout.writestr(name, zin.read(name))
                        deleted_all = False
                    else:
                        cnt_deleted += 1
            # Remove the original zipfile and replace it with new one
            os.remove(block_archive)
            if deleted_all:
                # Delete the empty zipfile
                os.remove(new_block_archive)
            else:
                os.rename(new_block_archive, block_archive)

        log.debug(&#39;Deleted %d certificates from block %s&#39;, cnt_deleted, block_archive)
        return cnt_deleted

    # static so I can use it in async pool
    @staticmethod
    def persist_certs(block_path: str, block_archive: str, certs: set) -&gt; int:
        &#34;&#34;&#34;Persist certificates to block archive&#34;&#34;&#34;
        if not certs:
            log.debug(&#39;Nothing to insert from block %s&#39;, block_path)
            return 0
        cnt_inserted = 0
        if os.path.exists(block_archive):
            append = True
            log.debug(&#39;Appending to archive: %s&#39;, block_archive)
        else:
            append = False
            log.debug(&#39;Creating archive: %s&#39;, block_archive)

        # TODO compare performance for higher compresslevel
        with ZipFile(block_archive, &#34;a&#34; if append else &#34;w&#34;, ZIP_DEFLATED) as zout:
            if append:
                persisted_certs = zout.namelist()

            for cert in certs:
                cert_file = block_path + cert
                if append and cert in persisted_certs:
                    pass  # do not insert duplicates
                else:
                    zout.write(cert_file, cert)
                    cnt_inserted += 1
                os.remove(cert_file)

        log.debug(&#39;Persisted %d certificates from block %s&#39;, cnt_inserted, block_path)
        return cnt_inserted

    def _is_in_transaction(self, cert_id: str, trans_dict: dict) -&gt; bool:
        return cert_id in trans_dict.get(self._get_block_id(cert_id), {})

    def _add_to_transaction(self, cert_id: str, trans_dict: dict) -&gt; None:
        block_id = self._get_block_id(cert_id)
        try:
            trans_dict[block_id].add(cert_id)
        except KeyError:
            trans_dict[block_id] = set()
            trans_dict[block_id].add(cert_id)

    def _remove_from_transaction(self, cert_id: str, trans_dict: dict) -&gt; None:
        block_id = self._get_block_id(cert_id)
        try:
            trans_dict[block_id].discard(cert_id)
            if not trans_dict[block_id]:
                del trans_dict[block_id]
        except KeyError:
            pass

    def __write_commit_info(self, inserted: int, deleted: int) -&gt; None:
        meta_path = os.path.join(self.storage, self.META_FILENAME)
        meta = toml.load(meta_path, OrderedDict)
        # Update DB INFO
        total_cnt = meta[&#39;INFO&#39;].get(&#39;number_of_certificates&#39;, 0)
        meta[&#39;INFO&#39;][&#39;number_of_certificates&#39;] = total_cnt + inserted - deleted
        meta[&#39;INFO&#39;][&#39;last_commit&#39;] = datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S%Z&#39;)
        # Append commit HISTORY
        if &#39;HISTORY&#39; not in meta:
            meta[&#39;HISTORY&#39;] = OrderedDict()
        commit_nr = str(len(meta[&#39;HISTORY&#39;]) + 1)
        meta[&#39;HISTORY&#39;][commit_nr] = OrderedDict()
        meta[&#39;HISTORY&#39;][commit_nr][&#39;date&#39;] = meta[&#39;INFO&#39;][&#39;last_commit&#39;]
        meta[&#39;HISTORY&#39;][commit_nr][&#39;inserted&#39;] = inserted
        meta[&#39;HISTORY&#39;][commit_nr][&#39;deleted&#39;] = deleted

        log.debug(meta)
        with open(meta_path, &#39;w&#39;) as meta_file:
            toml.dump(meta, meta_file)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cevast.certdb.cert_file_db.CertFileDB"><code class="flex name class">
<span>class <span class="ident">CertFileDB</span></span>
<span>(</span><span>storage: str, cpu_cores: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>CertDB interface implementation which uses files
and a file system properties as a storage mechanism.</p>
<p><code>storage</code> is path to the database storage.
<code>cpu_cores</code> is max number of CPU cores that might be used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CertFileDB(CertDB, CertFileDBReadOnly):
    &#34;&#34;&#34;
    CertDB interface implementation which uses files
    and a file system properties as a storage mechanism.

    `storage` is path to the database storage.
    `cpu_cores` is max number of CPU cores that might be used.
    &#34;&#34;&#34;

    def __init__(self, storage: str, cpu_cores: int = 1):
        CertFileDBReadOnly.__init__(self, storage)
        # Dict containing all inserted certificates grouped in blocks that will be persisted with commit
        self._to_insert: dict = {}
        # Dict containing all deleted certificates grouped in blocks that will be deleted with commit
        self._to_delete: dict = {}
        # Max number of CPU cores that can be used (-1 is max limit by hardware)
        self.__cpu_cores = int(cpu_cores)
        log.info(&#39;Will use %d CPUs&#39;, self.__cpu_cores)
        # Redefine _get_block_id method for special case with structure_level = 0
        if self._params[&#39;structure_level&#39;] == 0:
            fixed_block_id = os.path.basename(storage)
            self._get_block_id = lambda _: fixed_block_id

    def get(self, cert_id: str) -&gt; str:
        # Check if certificate exists as a file (transaction still open)
        if self._is_in_transaction(cert_id, self._to_insert):
            cert_file = self._get_block_path(cert_id) + cert_id
            with open(cert_file, &#39;r&#39;) as source:
                log.debug(&#39;&lt;%s&gt; found in open transaction&#39;, cert_file)
                return source.read()
        # Check if certificate is scheduled for delete
        if self._is_in_transaction(cert_id, self._to_delete):
            log.info(&#39;&lt;%s&gt; was deleted in current transaction&#39;, cert_id)
            raise CertNotAvailableError(cert_id)
        # Check if certificate exists persisted
        return CertFileDBReadOnly.get(self, cert_id)

    def export(self, cert_id: str, target_dir: str, copy_if_exists: bool = True) -&gt; str:
        # Check if certificate exists as a file (transaction still open)
        if self._is_in_transaction(cert_id, self._to_insert):
            cert_src_file = self._get_block_path(cert_id) + cert_id
            log.debug(&#39;&lt;%s&gt; found in open transaction&#39;, cert_src_file)
            if not copy_if_exists:
                return cert_src_file
            # Copy file to the target directory
            cert_trg_file = os.path.join(target_dir, make_PEM_filename(cert_id))
            shutil.copyfile(cert_src_file, cert_trg_file)
            return cert_trg_file
        # Check if certificate is scheduled for delete
        if self._is_in_transaction(cert_id, self._to_delete):
            log.info(&#39;&lt;%s&gt; was deleted in current transaction&#39;, cert_id)
            raise CertNotAvailableError(cert_id)
        # Check if certificate exists persisted
        return CertFileDBReadOnly.export(self, cert_id, target_dir, copy_if_exists)

    def exists(self, cert_id: str) -&gt; bool:
        # Check the open transaction first
        if self._is_in_transaction(cert_id, self._to_insert):
            log.debug(&#39;&lt;%s&gt; exists in open transaction&#39;, cert_id)
            return True
        # Check if certificate is scheduled for delete
        if self._is_in_transaction(cert_id, self._to_delete):
            log.info(&#39;&lt;%s&gt; was deleted in current transaction&#39;, cert_id)
            return False
        # Check if certificate exists persisted
        return CertFileDBReadOnly.exists(self, cert_id)

    def insert(self, cert_id: str, cert: str) -&gt; None:
        if not cert_id or not cert:
            raise CertInvalidError(&#39;cert_id &lt;{}&gt; or cert &lt;{}&gt; invalid&#39;.format(cert_id, cert))
        # Save certificate to temporary file
        block = self._get_block_path(cert_id)
        cert_file = block + cert_id
        if os.path.exists(cert_file):
            log.info(&#39;Certificate %s already exists&#39;, cert_file)
            return

        try:
            with open(cert_file, &#39;w&#39;) as w_file:
                w_file.write(cert)
        except FileNotFoundError:
            os.makedirs(block, exist_ok=True)
            with open(cert_file, &#39;w&#39;) as w_file:
                w_file.write(cert)

        # Add certificate to transaction for insert upon commit
        self._add_to_transaction(cert_id, self._to_insert)
        log.debug(&#39;Certificate %s inserted to block %s&#39;, cert_id, block)

    def delete(self, cert_id: str) -&gt; None:
        if not cert_id:
            raise CertInvalidError(&#39;cert_id &lt;{}&gt; invalid&#39;.format(cert_id))

        if self._is_in_transaction(cert_id, self._to_insert):
            # Immediatelly delete certificate in open transaction if exists
            cert_file = self._get_block_path(cert_id) + cert_id
            self._remove_from_transaction(cert_id, self._to_insert)
            os.remove(cert_file)
            log.debug(&#39;Certificate %s deleted from open transaction&#39;, cert_id)
        else:
            # Add certificate to transaction for delete upon commit
            self._add_to_transaction(cert_id, self._to_delete)
            log.debug(&#39;Certificate %s will be deleted upon commit&#39;, cert_id)

        # Delete certificates from cache
        self._cache.discard(cert_id)

    def rollback(self) -&gt; None:
        log.info(&#39;Rollback started&#39;)
        # Remove uncommitted certificates
        for block, certs in self._to_insert.items():
            block_path = self._get_block_path(block)
            for cert_id in certs:
                os.remove(block_path + cert_id)
        self._to_insert.clear()
        self._to_delete.clear()
        # Clean up empty folders
        remove_empty_folders(self.storage)
        log.info(&#39;Rollback finished&#39;)

    def commit(self) -&gt; Tuple[int, int]:
        log.info(&#39;Commit started&#39;)
        cnt_deleted = 0
        cnt_inserted = 0

        if self.__cpu_cores != 1:
            cnt_inserted, cnt_deleted = self.__commit_async()
        else:
            # Handle delete first because sequence matter
            for block, certs in self._to_delete.items():
                cnt_deleted += CertFileDB.delete_certs(self._get_block_archive(block), certs)
            # Now handle insert
            for block, certs in self._to_insert.items():
                cnt_inserted += CertFileDB.persist_certs(self._get_block_path(block), self._get_block_archive(block), certs)

        self._to_delete.clear()
        self._to_insert.clear()
        log.info(&#39;Deleted %d certificates&#39;, cnt_deleted)
        log.info(&#39;Inserted %d certificates&#39;, cnt_inserted)
        # Clean up empty folders
        remove_empty_folders(self.storage)  # TODO seems not working properly in benchmark
        # Write commit info
        if self._params[&#39;maintain_info&#39;]:
            self.__write_commit_info(cnt_inserted, cnt_deleted)
        log.info(&#39;Commit finished&#39;)
        return cnt_inserted, cnt_deleted

    def __commit_async(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;
        Function acomplishing the same as commit() but with use of multiprocessing.Pool
        of asynchronous workers to persist/delete multiple certificate blocks in parallel.
        &#34;&#34;&#34;
        cnt_deleted = 0
        cnt_inserted = 0
        cpus = self.__cpu_cores if self.__cpu_cores &gt; 0 else None

        pool = mp.Pool(cpus)
        # Handle delete first because sequence matter
        results = []
        for block, certs in self._to_delete.items():
            results.append(pool.apply_async(CertFileDB.delete_certs, args=(self._get_block_archive(block), certs)))
        cnt_deleted = sum([result.get() for result in results])
        # Now handle insert
        results = []
        for block, certs in self._to_insert.items():
            results.append(
                pool.apply_async(
                    CertFileDB.persist_certs, args=(self._get_block_path(block), self._get_block_archive(block), certs)
                )
            )
        cnt_inserted = sum([result.get() for result in results])
        pool.close()
        pool.join()

        return cnt_inserted, cnt_deleted

    # static so I can use it in async pool or find a way hot to use private
    @staticmethod
    def delete_certs(block_archive: str, certs: set) -&gt; int:
        &#34;&#34;&#34;Delete persisted certificates from block archive&#34;&#34;&#34;
        cnt_deleted = 0
        if certs and os.path.exists(block_archive):
            deleted_all = True
            new_block_archive = block_archive + &#39;_new&#39;
            with ZipFile(block_archive, &#39;r&#39;, ZIP_DEFLATED) as zin,\
                 ZipFile(new_block_archive, &#39;w&#39;, ZIP_DEFLATED) as zout:
                for name in zin.namelist():
                    if os.path.splitext(name)[0] not in certs:
                        zout.writestr(name, zin.read(name))
                        deleted_all = False
                    else:
                        cnt_deleted += 1
            # Remove the original zipfile and replace it with new one
            os.remove(block_archive)
            if deleted_all:
                # Delete the empty zipfile
                os.remove(new_block_archive)
            else:
                os.rename(new_block_archive, block_archive)

        log.debug(&#39;Deleted %d certificates from block %s&#39;, cnt_deleted, block_archive)
        return cnt_deleted

    # static so I can use it in async pool
    @staticmethod
    def persist_certs(block_path: str, block_archive: str, certs: set) -&gt; int:
        &#34;&#34;&#34;Persist certificates to block archive&#34;&#34;&#34;
        if not certs:
            log.debug(&#39;Nothing to insert from block %s&#39;, block_path)
            return 0
        cnt_inserted = 0
        if os.path.exists(block_archive):
            append = True
            log.debug(&#39;Appending to archive: %s&#39;, block_archive)
        else:
            append = False
            log.debug(&#39;Creating archive: %s&#39;, block_archive)

        # TODO compare performance for higher compresslevel
        with ZipFile(block_archive, &#34;a&#34; if append else &#34;w&#34;, ZIP_DEFLATED) as zout:
            if append:
                persisted_certs = zout.namelist()

            for cert in certs:
                cert_file = block_path + cert
                if append and cert in persisted_certs:
                    pass  # do not insert duplicates
                else:
                    zout.write(cert_file, cert)
                    cnt_inserted += 1
                os.remove(cert_file)

        log.debug(&#39;Persisted %d certificates from block %s&#39;, cnt_inserted, block_path)
        return cnt_inserted

    def _is_in_transaction(self, cert_id: str, trans_dict: dict) -&gt; bool:
        return cert_id in trans_dict.get(self._get_block_id(cert_id), {})

    def _add_to_transaction(self, cert_id: str, trans_dict: dict) -&gt; None:
        block_id = self._get_block_id(cert_id)
        try:
            trans_dict[block_id].add(cert_id)
        except KeyError:
            trans_dict[block_id] = set()
            trans_dict[block_id].add(cert_id)

    def _remove_from_transaction(self, cert_id: str, trans_dict: dict) -&gt; None:
        block_id = self._get_block_id(cert_id)
        try:
            trans_dict[block_id].discard(cert_id)
            if not trans_dict[block_id]:
                del trans_dict[block_id]
        except KeyError:
            pass

    def __write_commit_info(self, inserted: int, deleted: int) -&gt; None:
        meta_path = os.path.join(self.storage, self.META_FILENAME)
        meta = toml.load(meta_path, OrderedDict)
        # Update DB INFO
        total_cnt = meta[&#39;INFO&#39;].get(&#39;number_of_certificates&#39;, 0)
        meta[&#39;INFO&#39;][&#39;number_of_certificates&#39;] = total_cnt + inserted - deleted
        meta[&#39;INFO&#39;][&#39;last_commit&#39;] = datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S%Z&#39;)
        # Append commit HISTORY
        if &#39;HISTORY&#39; not in meta:
            meta[&#39;HISTORY&#39;] = OrderedDict()
        commit_nr = str(len(meta[&#39;HISTORY&#39;]) + 1)
        meta[&#39;HISTORY&#39;][commit_nr] = OrderedDict()
        meta[&#39;HISTORY&#39;][commit_nr][&#39;date&#39;] = meta[&#39;INFO&#39;][&#39;last_commit&#39;]
        meta[&#39;HISTORY&#39;][commit_nr][&#39;inserted&#39;] = inserted
        meta[&#39;HISTORY&#39;][commit_nr][&#39;deleted&#39;] = deleted

        log.debug(meta)
        with open(meta_path, &#39;w&#39;) as meta_file:
            toml.dump(meta, meta_file)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cevast.certdb.cert_db.CertDB" href="cert_db.html#cevast.certdb.cert_db.CertDB">CertDB</a></li>
<li><a title="cevast.certdb.cert_file_db.CertFileDBReadOnly" href="#cevast.certdb.cert_file_db.CertFileDBReadOnly">CertFileDBReadOnly</a></li>
<li><a title="cevast.certdb.cert_db.CertDBReadOnly" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly">CertDBReadOnly</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="cevast.certdb.cert_file_db.CertFileDB.delete_certs"><code class="name flex">
<span>def <span class="ident">delete_certs</span></span>(<span>block_archive: str, certs: set) -> int</span>
</code></dt>
<dd>
<div class="desc"><p>Delete persisted certificates from block archive</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def delete_certs(block_archive: str, certs: set) -&gt; int:
    &#34;&#34;&#34;Delete persisted certificates from block archive&#34;&#34;&#34;
    cnt_deleted = 0
    if certs and os.path.exists(block_archive):
        deleted_all = True
        new_block_archive = block_archive + &#39;_new&#39;
        with ZipFile(block_archive, &#39;r&#39;, ZIP_DEFLATED) as zin,\
             ZipFile(new_block_archive, &#39;w&#39;, ZIP_DEFLATED) as zout:
            for name in zin.namelist():
                if os.path.splitext(name)[0] not in certs:
                    zout.writestr(name, zin.read(name))
                    deleted_all = False
                else:
                    cnt_deleted += 1
        # Remove the original zipfile and replace it with new one
        os.remove(block_archive)
        if deleted_all:
            # Delete the empty zipfile
            os.remove(new_block_archive)
        else:
            os.rename(new_block_archive, block_archive)

    log.debug(&#39;Deleted %d certificates from block %s&#39;, cnt_deleted, block_archive)
    return cnt_deleted</code></pre>
</details>
</dd>
<dt id="cevast.certdb.cert_file_db.CertFileDB.persist_certs"><code class="name flex">
<span>def <span class="ident">persist_certs</span></span>(<span>block_path: str, block_archive: str, certs: set) -> int</span>
</code></dt>
<dd>
<div class="desc"><p>Persist certificates to block archive</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def persist_certs(block_path: str, block_archive: str, certs: set) -&gt; int:
    &#34;&#34;&#34;Persist certificates to block archive&#34;&#34;&#34;
    if not certs:
        log.debug(&#39;Nothing to insert from block %s&#39;, block_path)
        return 0
    cnt_inserted = 0
    if os.path.exists(block_archive):
        append = True
        log.debug(&#39;Appending to archive: %s&#39;, block_archive)
    else:
        append = False
        log.debug(&#39;Creating archive: %s&#39;, block_archive)

    # TODO compare performance for higher compresslevel
    with ZipFile(block_archive, &#34;a&#34; if append else &#34;w&#34;, ZIP_DEFLATED) as zout:
        if append:
            persisted_certs = zout.namelist()

        for cert in certs:
            cert_file = block_path + cert
            if append and cert in persisted_certs:
                pass  # do not insert duplicates
            else:
                zout.write(cert_file, cert)
                cnt_inserted += 1
            os.remove(cert_file)

    log.debug(&#39;Persisted %d certificates from block %s&#39;, cnt_inserted, block_path)
    return cnt_inserted</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="cevast.certdb.cert_db.CertDB" href="cert_db.html#cevast.certdb.cert_db.CertDB">CertDB</a></b></code>:
<ul class="hlist">
<li><code><a title="cevast.certdb.cert_db.CertDB.commit" href="cert_db.html#cevast.certdb.cert_db.CertDB.commit">commit</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDB.delete" href="cert_db.html#cevast.certdb.cert_db.CertDB.delete">delete</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDB.exists" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.exists">exists</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDB.exists_all" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.exists_all">exists_all</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDB.export" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.export">export</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDB.get" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.get">get</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDB.insert" href="cert_db.html#cevast.certdb.cert_db.CertDB.insert">insert</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDB.rollback" href="cert_db.html#cevast.certdb.cert_db.CertDB.rollback">rollback</a></code></li>
</ul>
</li>
<li><code><b><a title="cevast.certdb.cert_file_db.CertFileDBReadOnly" href="#cevast.certdb.cert_file_db.CertFileDBReadOnly">CertFileDBReadOnly</a></b></code>:
<ul class="hlist">
<li><code><a title="cevast.certdb.cert_file_db.CertFileDBReadOnly.setup" href="#cevast.certdb.cert_file_db.CertFileDBReadOnly.setup">setup</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="cevast.certdb.cert_file_db.CertFileDBReadOnly"><code class="flex name class">
<span>class <span class="ident">CertFileDBReadOnly</span></span>
<span>(</span><span>storage: str)</span>
</code></dt>
<dd>
<div class="desc"><p>CertDBReadOnly interface implementation which uses files
and a file system properties as a storage mechanism.</p>
<p><code>storage</code> is path to the database storage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CertFileDBReadOnly(CertDBReadOnly):
    &#34;&#34;&#34;
    CertDBReadOnly interface implementation which uses files
    and a file system properties as a storage mechanism.

    `storage` is path to the database storage.
    &#34;&#34;&#34;

    CONF_FILENAME = &#39;CertFileDB.toml&#39;
    META_FILENAME = &#39;.CertFileDB-META.toml&#39;

    @staticmethod
    def setup(storage_path: str, structure_level: int = 2, cert_format: str = &#39;PEM&#39;,
              desc: str = &#39;CertFileDB&#39;, owner: str = &#39;&#39;, maintain_info: bool = True) -&gt; None:
        &#34;&#34;&#34;
        Setup CertFileDB storage directory with the given parameters.
        Directory, configuration and META file is created.
        Raise ValueError for wrong parameters or if DB already exists.
        &#34;&#34;&#34;
        storage_path = os.path.abspath(storage_path)
        config_path = os.path.join(storage_path, CertFileDB.CONF_FILENAME)
        meta_path = os.path.join(storage_path, CertFileDB.META_FILENAME)
        if os.path.exists(config_path):
            raise ValueError(&#39;CertFileDB already exists&#39;)
        if not isinstance(structure_level, int):
            raise ValueError(&#39;structure_level must be an integer&#39;)
        os.makedirs(storage_path, exist_ok=True)
        # Create configuration file
        config = OrderedDict()
        config[&#39;PARAMETERS&#39;] = OrderedDict()
        config[&#39;PARAMETERS&#39;][&#39;storage&#39;] = storage_path
        config[&#39;PARAMETERS&#39;][&#39;structure_level&#39;] = structure_level
        config[&#39;PARAMETERS&#39;][&#39;cert_format&#39;] = cert_format
        config[&#39;PARAMETERS&#39;][&#39;compression_method&#39;] = &#39;ZIP_DEFLATED&#39;
        config[&#39;PARAMETERS&#39;][&#39;maintain_info&#39;] = maintain_info
        with open(config_path, &#39;w&#39;) as cfg_file:
            toml.dump(config, cfg_file)
        # Create META file
        meta = OrderedDict()
        meta[&#39;INFO&#39;] = OrderedDict()
        meta[&#39;INFO&#39;][&#39;owner&#39;] = owner
        meta[&#39;INFO&#39;][&#39;description&#39;] = desc
        meta[&#39;INFO&#39;][&#39;created&#39;] = datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S%Z&#39;)
        with open(meta_path, &#39;w&#39;) as meta_file:
            toml.dump(meta, meta_file)

        log.info(&#39;CertFileDB was setup:\n%s&#39;, config)

    def __init__(self, storage: str):
        # Get config
        try:
            config_path = os.path.join(os.path.abspath(storage), self.CONF_FILENAME)
            self.storage = os.path.abspath(storage)
            config = toml.load(config_path)
            self._params = config[&#39;PARAMETERS&#39;]
            log.info(&#39;Found CertFileDB &lt;%s&gt;:\n%s&#39;, config_path, config)
        except FileNotFoundError:
            raise ValueError(&#39;CertFileDB &lt;{}&gt; does not exists -&gt; call CertFileDB.setup() first&#39;.format(config_path))
        # Init DB instance
        log.info(&#39;Initializing %s transaction...&#39;, self.__class__.__name__)
        # Set maintaining all known certificate IDs for better EXISTS performance
        self._cache: set = set()
        # Pre-compute index used for block_id
        self._block_id_index = self._params[&#39;structure_level&#39;] + 1

    def get(self, cert_id: str) -&gt; str:
        # Check if certificate exists
        try:
            zip_file = self._get_block_archive(cert_id)
            with ZipFile(zip_file, &#39;r&#39;, ZIP_DEFLATED) as z_obj:
                with z_obj.open(cert_id) as cert:
                    log.debug(&#39;&lt;%s&gt; found persisted in zip &lt;%s&gt;&#39;, cert_id, zip_file)
                    return cert.read().decode(&#39;utf-8&#39;)
        except (KeyError, FileNotFoundError):
            pass

        log.info(&#39;&lt;%s&gt; not found&#39;, cert_id)
        if cert_id in self._cache:
            self._cache.clear()  # Cache seems to be invalidated, so clear it
        raise CertNotAvailableError(cert_id)

    def export(self, cert_id: str, target_dir: str, copy_if_exists: bool = True) -&gt; str:
        # Check if certificate exists persisted
        try:
            zip_file = self._get_block_archive(cert_id)
            with ZipFile(zip_file, &#39;r&#39;, ZIP_DEFLATED) as z_obj:
                zipinfo = z_obj.getinfo(cert_id)
                zipinfo.filename = make_PEM_filename(cert_id)
                z_obj.extract(zipinfo, target_dir)
                log.debug(&#39;&lt;%s&gt; found persisted in zip &lt;%s&gt;&#39;, cert_id, zip_file)
                return os.path.join(target_dir, make_PEM_filename(cert_id))
        except (KeyError, FileNotFoundError):
            pass

        log.info(&#39;&lt;%s&gt; not found&#39;, cert_id)
        if cert_id in self._cache:
            self._cache.clear()  # Cache seems to be invalidated, so clear it
        raise CertNotAvailableError(cert_id)

    def exists(self, cert_id: str) -&gt; bool:
        # Check cache first
        if cert_id in self._cache:
            log.debug(&#39;&lt;%s&gt; found in cache&#39;, cert_id)
            return True

        # Check if certificate exists persisted
        try:
            zip_file = self._get_block_archive(cert_id)
            with ZipFile(zip_file, &#39;r&#39;, ZIP_DEFLATED) as z_obj:
                z_obj.getinfo(cert_id)
                log.debug(&#39;&lt;%s&gt; exists persisted &lt;%s&gt;&#39;, cert_id, zip_file)
                self._cache.add(cert_id)
                return True
        except (KeyError, FileNotFoundError):
            pass

        log.debug(&#39;&lt;%s&gt; does not exist&#39;, cert_id)
        return False

    def exists_all(self, cert_ids: list) -&gt; bool:
        for cert_id in cert_ids:
            if not self.exists(cert_id):
                return False

        return True

    def _get_block_path(self, cert_or_block_id: str) -&gt; str:
        &#34;&#34;&#34;Return full block path of certificate or block id&#34;&#34;&#34;
        paths = [cert_or_block_id[: 2 + i] for i in range(self._params[&#39;structure_level&#39;])]
        return &#34;/&#34;.join([self._params[&#39;storage&#39;]] + paths) + &#39;/&#39;

    def _get_block_id(self, cert_id: str) -&gt; str:  # pylint: disable=E0202
        return cert_id[: self._block_id_index]

    def _get_block_archive(self, cert_or_block_id: str) -&gt; str:
        block_path = self._get_block_path(cert_or_block_id)
        return block_path + self._get_block_id(cert_or_block_id) + &#39;.zip&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cevast.certdb.cert_db.CertDBReadOnly" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly">CertDBReadOnly</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="cevast.certdb.cert_file_db.CertFileDB" href="#cevast.certdb.cert_file_db.CertFileDB">CertFileDB</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="cevast.certdb.cert_file_db.CertFileDBReadOnly.CONF_FILENAME"><code class="name">var <span class="ident">CONF_FILENAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cevast.certdb.cert_file_db.CertFileDBReadOnly.META_FILENAME"><code class="name">var <span class="ident">META_FILENAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="cevast.certdb.cert_file_db.CertFileDBReadOnly.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>storage_path: str, structure_level: int = 2, cert_format: str = 'PEM', desc: str = 'CertFileDB', owner: str = '', maintain_info: bool = True) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Setup CertFileDB storage directory with the given parameters.
Directory, configuration and META file is created.
Raise ValueError for wrong parameters or if DB already exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def setup(storage_path: str, structure_level: int = 2, cert_format: str = &#39;PEM&#39;,
          desc: str = &#39;CertFileDB&#39;, owner: str = &#39;&#39;, maintain_info: bool = True) -&gt; None:
    &#34;&#34;&#34;
    Setup CertFileDB storage directory with the given parameters.
    Directory, configuration and META file is created.
    Raise ValueError for wrong parameters or if DB already exists.
    &#34;&#34;&#34;
    storage_path = os.path.abspath(storage_path)
    config_path = os.path.join(storage_path, CertFileDB.CONF_FILENAME)
    meta_path = os.path.join(storage_path, CertFileDB.META_FILENAME)
    if os.path.exists(config_path):
        raise ValueError(&#39;CertFileDB already exists&#39;)
    if not isinstance(structure_level, int):
        raise ValueError(&#39;structure_level must be an integer&#39;)
    os.makedirs(storage_path, exist_ok=True)
    # Create configuration file
    config = OrderedDict()
    config[&#39;PARAMETERS&#39;] = OrderedDict()
    config[&#39;PARAMETERS&#39;][&#39;storage&#39;] = storage_path
    config[&#39;PARAMETERS&#39;][&#39;structure_level&#39;] = structure_level
    config[&#39;PARAMETERS&#39;][&#39;cert_format&#39;] = cert_format
    config[&#39;PARAMETERS&#39;][&#39;compression_method&#39;] = &#39;ZIP_DEFLATED&#39;
    config[&#39;PARAMETERS&#39;][&#39;maintain_info&#39;] = maintain_info
    with open(config_path, &#39;w&#39;) as cfg_file:
        toml.dump(config, cfg_file)
    # Create META file
    meta = OrderedDict()
    meta[&#39;INFO&#39;] = OrderedDict()
    meta[&#39;INFO&#39;][&#39;owner&#39;] = owner
    meta[&#39;INFO&#39;][&#39;description&#39;] = desc
    meta[&#39;INFO&#39;][&#39;created&#39;] = datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S%Z&#39;)
    with open(meta_path, &#39;w&#39;) as meta_file:
        toml.dump(meta, meta_file)

    log.info(&#39;CertFileDB was setup:\n%s&#39;, config)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="cevast.certdb.cert_db.CertDBReadOnly" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly">CertDBReadOnly</a></b></code>:
<ul class="hlist">
<li><code><a title="cevast.certdb.cert_db.CertDBReadOnly.exists" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.exists">exists</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDBReadOnly.exists_all" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.exists_all">exists_all</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDBReadOnly.export" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.export">export</a></code></li>
<li><code><a title="cevast.certdb.cert_db.CertDBReadOnly.get" href="cert_db.html#cevast.certdb.cert_db.CertDBReadOnly.get">get</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cevast.certdb" href="index.html">cevast.certdb</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cevast.certdb.cert_file_db.CertFileDB" href="#cevast.certdb.cert_file_db.CertFileDB">CertFileDB</a></code></h4>
<ul class="">
<li><code><a title="cevast.certdb.cert_file_db.CertFileDB.delete_certs" href="#cevast.certdb.cert_file_db.CertFileDB.delete_certs">delete_certs</a></code></li>
<li><code><a title="cevast.certdb.cert_file_db.CertFileDB.persist_certs" href="#cevast.certdb.cert_file_db.CertFileDB.persist_certs">persist_certs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cevast.certdb.cert_file_db.CertFileDBReadOnly" href="#cevast.certdb.cert_file_db.CertFileDBReadOnly">CertFileDBReadOnly</a></code></h4>
<ul class="">
<li><code><a title="cevast.certdb.cert_file_db.CertFileDBReadOnly.CONF_FILENAME" href="#cevast.certdb.cert_file_db.CertFileDBReadOnly.CONF_FILENAME">CONF_FILENAME</a></code></li>
<li><code><a title="cevast.certdb.cert_file_db.CertFileDBReadOnly.META_FILENAME" href="#cevast.certdb.cert_file_db.CertFileDBReadOnly.META_FILENAME">META_FILENAME</a></code></li>
<li><code><a title="cevast.certdb.cert_file_db.CertFileDBReadOnly.setup" href="#cevast.certdb.cert_file_db.CertFileDBReadOnly.setup">setup</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>